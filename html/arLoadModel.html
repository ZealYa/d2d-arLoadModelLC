
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>arLoadModel</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-03-15"><meta name="DC.source" content="arLoadModel.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">% Load Model definition to next free index position</span>
<span class="comment">%</span>
<span class="comment">% arLoadModel(name)</span>
<span class="comment">%</span>
<span class="comment">% name      filename of model definition file</span>
<span class="comment">% m         model index for the model to go into</span>
<span class="comment">%</span>
<span class="comment">% Copyright Andreas Raue 2011 (andreas.raue@fdm.uni-freiburg.de)</span>

<span class="comment">% regexp('test-&gt;5-&gt;test', '-&gt;\d-&gt;', 'Match')</span>

<span class="keyword">function</span> arLoadModel(name, m, varargin)

<span class="keyword">global</span> ar

<span class="keyword">if</span>(isempty(ar))
    error(<span class="string">'please initialize by arInit'</span>)
<span class="keyword">end</span>

<span class="comment">% custom</span>
switches = { <span class="string">'conditions'</span> };
extraArgs = [ 1 ];
description = { <span class="keyword">...</span>
    {<span class="string">''</span>, <span class="string">'Specified extra conditions'</span>} };

opts = argSwitch( switches, extraArgs, description, 1, varargin );

<span class="comment">% load model from mat-file</span>
<span class="keyword">if</span>(~exist(<span class="string">'Models'</span>,<span class="string">'dir'</span>))
    error(<span class="string">'folder Models/ does not exist'</span>)
<span class="keyword">end</span>
<span class="keyword">if</span> strcmp(strrep(name,<span class="string">' '</span>,<span class="string">''</span>),name)~=1
    name
    error(<span class="string">'File names should not contain empty spaces. Please remove it.'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span>(~exist([<span class="string">'Models/'</span> name <span class="string">'.def'</span>],<span class="string">'file'</span>))
    error(<span class="string">'model definition file %s.def does not exist in folder Models/'</span>, name)
<span class="keyword">end</span>

<span class="keyword">if</span>(~exist(<span class="string">'m'</span>,<span class="string">'var'</span>))
    <span class="keyword">if</span>(isfield(ar, <span class="string">'model'</span>))
        m = length(ar.model) + 1;
    <span class="keyword">else</span>
        m = 1;
    <span class="keyword">end</span>
<span class="keyword">else</span>
    error([<span class="string">'Usage arLoadModel(name, m) is deprecated. Please use arLoadModel(name) '</span> <span class="keyword">...</span>
        <span class="string">'and note that the model will be loaded to the next free index position by default.'</span>]);
<span class="keyword">end</span>

<span class="comment">% Disable this if you are having problems because of the preprocessor</span>
preprocessor = 1;
arFprintf(1, <span class="string">'loading model #%i, from file Models/%s.def...\n'</span>, m, name);
<span class="keyword">if</span> ( ~preprocessor )
    fid = fopen([<span class="string">'Models/'</span> name <span class="string">'.def'</span>], <span class="string">'r'</span>);
<span class="keyword">else</span>
    <span class="comment">% Load into a struct</span>
    fid.fn  = [<span class="string">'Models/'</span> name <span class="string">'.def'</span>];
    fid.str = fileread([<span class="string">'Models/'</span> name <span class="string">'.def'</span>]);
    fid.pos = 1;

    fid = arPreProcessor(fid);
<span class="keyword">end</span>

<span class="comment">% initial setup</span>
ar.model(m).name = name;
ar.model(m).path = [pwd,filesep,<span class="string">'Models'</span>,filesep];

<span class="comment">% Validate input</span>
<span class="keyword">if</span> ( opts.conditions )
    <span class="keyword">if</span> ~(size( opts.conditions_args, 2 ) == 2) || ~iscell( opts.conditions_args )
        error( <span class="string">'Additional conditions should be given in Mx2 cell array.'</span> );
    <span class="keyword">else</span>
        ar.model(m).extra_conditions = opts.conditions_args;
    <span class="keyword">end</span>
<span class="keyword">else</span>
    ar.model(m).extra_conditions = {};
<span class="keyword">end</span>

matVer = ver(<span class="string">'MATLAB'</span>);

<span class="comment">% AAA - Check if delay is there</span>
<span class="comment">%delayCh.modelAsString = fileread(['Models/' name '.def']); nicht ben&ouml;tigt</span>
<span class="comment">%wegen fid.str</span>
delayCh.indicator = regexp(fid.str, <span class="string">'-\d-&gt;'</span>, <span class="string">'Match'</span>);
<span class="keyword">if</span>(~isempty(delayCh.indicator))
    delayCh.length = str2num(delayCh.indicator{1}(2));
    delayCh.position = 1;
    delayCh.bl = 1;
    delayCh.ctr = 1;
<span class="keyword">else</span>
    delayCh.bl = 0;
<span class="keyword">end</span>

<span class="comment">% DESCRIPTION</span>
[str, fid] = arTextScan(fid, <span class="string">'%s'</span>, 1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">if</span>(isempty(strfind(str{1},<span class="string">'DESCRIPTION'</span>)))
    arParsingError( fid, <span class="string">'parsing model %s for DESCRIPTION'</span>, ar.model(m).name);
<span class="keyword">end</span>

<span class="comment">% check version</span>
<span class="keyword">if</span>(strcmp(str{1},<span class="string">'DESCRIPTION'</span>))
    <span class="comment">% def_version = 1;</span>
<span class="keyword">elseif</span>(strcmp(str{1},<span class="string">'DESCRIPTION-V2'</span>))
    arParsingError( fid, <span class="string">'DESCRIPTION-V2 not supported yet'</span>);
<span class="keyword">else</span>
    arParsingError( fid, <span class="string">'invalid version identifier: %s'</span>, cell2mat(str{1}));
<span class="keyword">end</span>

<span class="comment">% read comments</span>
[str, fid] = arTextScan(fid, <span class="string">'%q'</span>, 1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
ar.model(m).description = {};
<span class="keyword">while</span>(~strcmp(str{1},<span class="string">'PREDICTOR'</span>))
    ar.model(m).description(end+1,1) = str{1};
    [str, fid] = arTextScan(fid, <span class="string">'%q'</span>, 1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">end</span>

<span class="comment">% PREDICTOR</span>
[C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %n %n\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
arValidateInput( C, <span class="string">'predictor'</span>, <span class="string">'identifier for independent variable'</span>, <span class="string">'unit type'</span>, <span class="string">'unit'</span>, <span class="string">'label for plotting'</span> );
ar.model(m).t = cell2mat(C{1});
ar.model(m).tUnits(1) = C{2};
ar.model(m).tUnits(2) = C{3};
ar.model(m).tUnits(3) = C{4};
ar.model(m).tLim = [checkNum(C{5}, 0) checkNum(C{6}, 10)];

<span class="comment">% COMPARTMENTS</span>
ar.model(m).c = {};
ar.model(m).cUnits = {};
ar.model(m).pc = {};
ar.model(m).px = {};
[C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %f\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">if</span>(~strcmp(C{1},<span class="string">'COMPARTMENTS'</span>))
    arParsingError( fid, <span class="string">'currently only one PREDICTOR allowed'</span>);
<span class="keyword">end</span>
<span class="keyword">while</span>(~strcmp(C{1},<span class="string">'STATES'</span>))
    <span class="keyword">if</span>(~strcmp(C{1},<span class="string">'COMPARTMENTS'</span>))
        arValidateInput( C, <span class="string">'compartments'</span>, <span class="string">'compartment'</span>, <span class="string">'unit type (i.e. V)'</span>, <span class="string">'unit (i.e. pl)'</span>, <span class="string">'label (i.e. "vol.")'</span> );
        ar.model(m).c(end+1) = C{1};
        ar.model(m).cUnits(end+1,1) = C{2};
        ar.model(m).cUnits(end,2) = C{3};
        ar.model(m).cUnits(end,3) = C{4};

        <span class="keyword">if</span>(isempty(C{5})||isnan(C{5}))
            ar.model(m).px(end+1) = {[<span class="string">'vol_'</span> cell2mat(C{1})]};
            ar.model(m).pc(end+1) = {[<span class="string">'vol_'</span> cell2mat(C{1})]};
        <span class="keyword">else</span>
            ar.model(m).pc(end+1) = {num2str(C{5})};
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    [C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %f\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">end</span>

<span class="comment">% STATES</span>
ar.model(m).px0 = {};
ar.model(m).x = {};
ar.model(m).xNames = {};
ar.model(m).xUnits = {};
ar.model(m).cLink = [];
ar.model(m).qPlotX = [];
ar.model(m).qPositiveX = [];
[C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %s %n %q %n\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">while</span>(~strcmp(C{1},<span class="string">'INPUTS'</span>))
    <span class="keyword">if</span> ( strcmp( C{1}, <span class="string">'REACTIONS'</span> ) )
        arParsingError( fid,  <span class="string">'Missing field INPUTS. This section should be specified after STATES and before REACTIONS. See: "Setting up models"'</span> );
    <span class="keyword">end</span>

    arValidateInput( C, <span class="string">'state'</span>, <span class="string">'unique identifier'</span>, <span class="string">'unit type (i.e. C)'</span>, <span class="string">'unit (i.e. nM)'</span>, <span class="string">'label for plots (i.e. "conc.")'</span> );

    <span class="keyword">if</span>(length(cell2mat(C{1}))&lt;2)
        arParsingError( fid, <span class="string">'STATE names need to be longer than 1'</span>);
    <span class="keyword">end</span>
    <span class="keyword">if</span>(isempty(symvar(sym(C{1}))))
        arParsingError( fid, <span class="string">'STATE name ''%s'' is reserved by MATLAB. Please rename!'</span>,cell2mat(C{1}));
    <span class="keyword">end</span>

    ar.model(m).x(end+1) = C{1};
    ar.model(m).xUnits(end+1,1) = C{2};
    ar.model(m).xUnits(end,2) = C{3};
    ar.model(m).xUnits(end,3) = C{4};
    <span class="keyword">if</span>(~isempty(ar.model(m).c))
        qcomp = ismember(ar.model(m).c, C{5}); <span class="comment">%R2013a compatible</span>
        <span class="keyword">if</span>(sum(qcomp)~=1)
            arParsingError( fid, <span class="string">'unknown compartment %s'</span>, cell2mat(C{5}));
        <span class="keyword">end</span>
        ar.model(m).cLink(end+1) = find(qcomp);
    <span class="keyword">end</span>
    <span class="keyword">if</span>(isempty(C{6}) || isnan(C{6}))
        ar.model(m).qPlotX(end+1) = 1;
    <span class="keyword">else</span>
        ar.model(m).qPlotX(end+1) = C{6};
    <span class="keyword">end</span>
    <span class="keyword">if</span>(~isempty(cell2mat(C{7})))
        ar.model(m).xNames(end+1) = C{7};
    <span class="keyword">else</span>
        ar.model(m).xNames{end+1} = ar.model(m).x{end};
    <span class="keyword">end</span>
    <span class="keyword">if</span>(isempty(C{8}) || isnan(C{8}))
        ar.model(m).qPositiveX(end+1) = 0;
    <span class="keyword">else</span>
        ar.model(m).qPositiveX(end+1) = C{8};
    <span class="keyword">end</span>
    ar.model(m).px0(end+1) = {[<span class="string">'init_'</span> cell2mat(C{1})]};

    [C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %s %n %q %n\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);

    <span class="comment">% AAA add delay states</span>
    <span class="keyword">if</span>(strcmp(C{1},<span class="string">'INPUTS'</span>) &amp; delayCh.bl == 1)

        delinpind = find(ismember(ar.model(end).x,<span class="string">'Delay_01'</span>));

        <span class="keyword">for</span> i = 2:delayCh.length
            C{1} = {sprintf(<span class="string">'Delay_%02d'</span>, i)};
            C{2} = ar.model(m).xUnits(delinpind,1);
            C{3} = ar.model(m).xUnits(delinpind,2);
            C{4} = ar.model(m).xUnits(delinpind,3);
            <span class="comment">%C{5} = compartments erg&auml;nzen</span>
            C{6} = ar.model(m).qPlotX(delinpind);
            C{7} = {[ar.model(m).xNames{delinpind} <span class="string">'_'</span> num2str(i)]};
            C{8} = ar.model(m).qPositiveX(delinpind);

            ar.model(m).x(end+1) = C{1};
            ar.model(m).xUnits(end+1,1) = C{2};
            ar.model(m).xUnits(end,2) = C{3};
            ar.model(m).xUnits(end,3) = C{4};

            <span class="keyword">if</span>(~isempty(ar.model(m).c))
                qcomp = ismember(ar.model(m).c, C{5}); <span class="comment">%R2013a compatible</span>
                <span class="keyword">if</span>(sum(qcomp)~=1)
                    arParsingError( fid, <span class="string">'unknown compartment %s'</span>, cell2mat(C{5}));
                <span class="keyword">end</span>
                ar.model(m).cLink(end+1) = find(qcomp);
            <span class="keyword">end</span>
            <span class="keyword">if</span>(isempty(C{6}) || isnan(C{6}))
                ar.model(m).qPlotX(end+1) = 1;
            <span class="keyword">else</span>
                ar.model(m).qPlotX(end+1) = C{6};
            <span class="keyword">end</span>
            <span class="keyword">if</span>(~isempty(cell2mat(C{7})))
                ar.model(m).xNames(end+1) = C{7};
            <span class="keyword">else</span>
                ar.model(m).xNames{end+1} = ar.model(m).x{end};
            <span class="keyword">end</span>
            <span class="keyword">if</span>(isempty(C{8}) || isnan(C{8}))
                ar.model(m).qPositiveX(end+1) = 0;
            <span class="keyword">else</span>
                ar.model(m).qPositiveX(end+1) = C{8};
            <span class="keyword">end</span>
            ar.model(m).px0(end+1) = {[<span class="string">'init_'</span> cell2mat(C{1})]};
        <span class="keyword">end</span>

        C{1} = <span class="string">'INPUTS'</span>; <span class="comment">%return to normal</span>
    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="comment">% add delay states</span>

<span class="comment">% INPUTS</span>
ar.model(m).u = {};
ar.model(m).uUnits = {};
ar.model(m).fu = {};
ar.model(m).uNames = {};
[C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %q %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">while</span>(~strcmp(C{1},<span class="string">'REACTIONS'</span>) &amp;&amp; ~strcmp(C{1},<span class="string">'REACTIONS-AMOUNTBASED'</span>) &amp;&amp; ~strcmp(C{1},<span class="string">'ODES'</span>))
    <span class="keyword">if</span>(~strcmp(C{1},<span class="string">''</span>))
        arValidateInput( C, <span class="string">'input'</span>, <span class="string">'unique input name'</span>, <span class="string">'unit type (i.e. C)'</span>, <span class="string">'unit (i.e. "units/cell")'</span>, <span class="string">'plain text label for plots ("conc.")'</span>, <span class="string">'input function'</span> );
        <span class="keyword">if</span>(sum(ismember(ar.model(m).x, C{1}))&gt;0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'input %s already defined in STATES'</span>, cell2mat(C{1}));
        <span class="keyword">end</span>
        ar.model(m).u(end+1) = C{1};
        ar.model(m).uUnits(end+1,1) = C{2};
        ar.model(m).uUnits(end,2) = C{3};
        ar.model(m).uUnits(end,3) = C{4};
        ar.model(m).fu(end+1,1) = C{5};
        <span class="keyword">if</span>(~isempty(cell2mat(C{6})))
            ar.model(m).uNames(end+1) = C{6};
        <span class="keyword">else</span>
            ar.model(m).uNames{end+1} = <span class="string">''</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    [C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %q %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">end</span>
ar.model(m).qPlotU = ones(size(ar.model(m).u));

<span class="comment">% input parameters</span>
varlist = cellfun(@symvar, ar.model(m).fu, <span class="string">'UniformOutput'</span>, false);
ar.model(m).pu = setdiff(vertcat(varlist{:}), {ar.model(m).t, <span class="string">''</span>}); <span class="comment">%R2013a compatible</span>

<span class="comment">% REACTIONS (or ODES)</span>
ar.model(m).N = [];
ar.model(m).v = {};
ar.model(m).fv = {};
ar.model(m).fv_source = {};
ar.model(m).fv_target = {};
ar.model(m).fv_sourceCoeffs = {};
ar.model(m).fv_targetCoeffs = {};
ar.model(m).reversible = [];
ar.model(m).fv_ma_reverse_pbasename = {};
ar.model(m).vUnits = {};
<span class="keyword">if</span>(strcmp(C{1},<span class="string">'REACTIONS'</span>) || strcmp(C{1},<span class="string">'REACTIONS-AMOUNTBASED'</span>))
    ar.model(m).isReactionBased = true;
    <span class="keyword">if</span>(strcmp(C{1},<span class="string">'REACTIONS-AMOUNTBASED'</span>))
        ar.model(m).isAmountBased = true;
    <span class="keyword">else</span>
        ar.model(m).isAmountBased = false;
    <span class="keyword">end</span>
    vcount = 1;
    <span class="comment">%str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);</span>

    <span class="comment">% Read single line (easier to trace errors back to their line)</span>

    <span class="comment">% AAA: Finde line in der Delay stattfindet:</span>
    <span class="comment">% line = 'Delay_01 -&gt; Delay_02 CUSTOM "k_delay*Delay_01"'</span>
    <span class="comment">% remainder = line;</span>
    <span class="comment">% fid = ;</span>
    <span class="comment">%</span>
    <span class="comment">% zum Beispiel</span>
<span class="comment">%     if fid.nlines == delayCh.position</span>
<span class="comment">%         line = 'Delay_01 -&gt; Delay_02 CUSTOM "k_delay*Delay_01"'</span>
<span class="comment">%         remainder = line;</span>
<span class="comment">%     else</span>
<span class="comment">%         [ line, remainder, fid ] = readLine( fid, ar.config.comment_string );</span>
<span class="comment">%     end</span>
<span class="comment">%</span>


    [ line, remainder, fid ] = readLine( fid, ar.config.comment_string );
    <span class="comment">%str = textscan(line, '%s', 1);</span>


    [str, remainder] = grabtoken( remainder, <span class="string">'%s'</span>, 1 );
    <span class="keyword">while</span>(~strcmp(str{1},<span class="string">'INVARIANTS'</span>) &amp;&amp; ~strcmp(str{1},<span class="string">'DERIVED'</span>))
        source = {};
        sourceCoeffs = [];

        <span class="keyword">if</span> ( strcmp(str{1}, <span class="string">'OBSERVABLES'</span>) || strcmp(str{1}, <span class="string">'CONDITIONS'</span>) )
            arParsingError( fid, <span class="string">'Missing field DERIVED. This section should be specified after REACTIONS and before OBSERVABLES / CONDITIONS. See: "Setting up models paragraph 1.7"'</span>);
        <span class="keyword">end</span>
        nextValue = 1;


<span class="comment">% while abfrage erg&auml;nzen um strcmp '-&gt;4-&gt;'</span>

        <span class="keyword">while</span>(~strcmp(str{1},<span class="string">'-&gt;'</span>) &amp;&amp; ~strcmp(str{1},<span class="string">'&lt;-&gt;'</span>) &amp;&amp; isempty(regexp(str{1}{1},<span class="string">'-\d-&gt;'</span>)))
            <span class="keyword">if</span>(~strcmp(str{1},<span class="string">'0'</span>) &amp;&amp; ~strcmp(str{1},<span class="string">'+'</span>))
                <span class="comment">% Check whether a stoichiometric coefficient is specified</span>
                <span class="keyword">if</span> ~isempty(str2num(str{1}{1})) <span class="comment">%#ok</span>
                    nextValue = str2num(str{1}{1}); <span class="comment">%#ok</span>
                <span class="keyword">else</span>
                    source(end+1) = str{1}; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    sourceCoeffs(end+1) = nextValue; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    nextValue = 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">%str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);</span>
            [str, remainder] = grabtoken( remainder, <span class="string">'%s'</span>, 1 );
            str{1}
            <span class="keyword">if</span> ( isempty(str{1}) )
                arParsingError( fid, <span class="string">'incomplete reaction definition in reaction %i: %s'</span>, vcount, line)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span>(sum(~ismember(source, ar.model(m).x)) &gt; 0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'%s\nundefined source species in reaction %i: %s'</span>, line, vcount, <span class="keyword">...</span>
                source{~ismember(source, ar.model(m).x)}) <span class="comment">%R2013a compatible</span>
        <span class="keyword">end</span>

        <span class="keyword">if</span>(strcmp(str{1},<span class="string">'&lt;-&gt;'</span>))
            reversible = true;
        <span class="keyword">else</span>
            reversible = false;
        <span class="keyword">end</span>

        <span class="comment">% AAA check if there is a delay in the current line</span>

<span class="comment">% DELAY-ABFRAGE EINF&Uuml;HREN -&gt; wenn positiv nach zuendelesen der aktuellen</span>
<span class="comment">% Zeile str ab&auml;ndern</span>

        ar.model(m).reversible(end+1) = reversible;

        target = {};
        targetCoeffs = [];
        nextValue = 1;
        <span class="comment">%str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);</span>
        [str, remainder] = grabtoken( remainder, <span class="string">'%s'</span>, 1 );
        <span class="keyword">while</span>(~strcmp(str{1},<span class="string">'CUSTOM'</span>) &amp;&amp; ~strcmp(str{1},<span class="string">'MASSACTION'</span>) &amp;&amp; ~strcmp(str{1},<span class="string">'MASSACTIONKD'</span>))
            <span class="keyword">if</span>(~strcmp(str{1},<span class="string">'0'</span>) &amp;&amp; ~strcmp(str{1},<span class="string">'+'</span>))
                <span class="comment">% Check whether a stoichiometric coefficient is specified</span>
                <span class="keyword">if</span> ( ~isempty(str2num(str{1}{1})) )  <span class="comment">%#ok</span>
                    nextValue = str2num(str{1}{1});   <span class="comment">%#ok</span>
                <span class="keyword">else</span>
                    target(end+1)       = str{1}; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    targetCoeffs(end+1) = nextValue; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    nextValue = 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">%str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);</span>
            [str, remainder] = grabtoken(remainder, <span class="string">'%s'</span>, 1);

            <span class="keyword">if</span> ( isempty( str{1} ) )
                arParsingError( fid, <span class="string">'missing keyword CUSTOM, MASSACTION or MASSACTIONKD before reaction rate expression'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span>(sum(~ismember(target, ar.model(m).x)) &gt; 0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'undefined target species in reaction %i: %s'</span>, vcount, <span class="keyword">...</span>
                target{~ismember(target, ar.model(m).x)}) <span class="comment">%R2013a compatible</span>
        <span class="keyword">end</span>

        <span class="comment">% infer flux units</span>
        <span class="keyword">if</span>(~isempty(source))
            ix = find(ismember(ar.model(m).x, source{1})); <span class="comment">%R2013a compatible</span>
        <span class="keyword">elseif</span>(~isempty(target))
            ix = find(ismember(ar.model(m).x, target{1})); <span class="comment">%R2013a compatible</span>
        <span class="keyword">else</span>
            arParsingError( fid, <span class="string">'reaction with empty N'</span>);
        <span class="keyword">end</span>
        ar.model(m).vUnits{end+1,1} = [ar.model(m).xUnits{ix,1} <span class="string">'/'</span> ar.model(m).tUnits{1}];
        ar.model(m).vUnits{end,2} = [ar.model(m).xUnits{ix,2} <span class="string">'/'</span> ar.model(m).tUnits{2}];
        ar.model(m).vUnits{end,3} = [ar.model(m).xUnits{ix,3} <span class="string">'/'</span> ar.model(m).tUnits{3}];

        <span class="keyword">if</span>(strcmp(str{1},<span class="string">'MASSACTION'</span>))
            massaction = true;
            massactionkd = false;
        <span class="keyword">else</span>
            massaction = false;
        <span class="keyword">end</span>
        <span class="keyword">if</span>(strcmp(str{1},<span class="string">'MASSACTIONKD'</span>))
            massaction = true;
            massactionkd = true;
        <span class="keyword">end</span>

        [C, remainder] = grabtoken(remainder, <span class="string">'%q %q'</span>, 1);

        <span class="comment">%C = arTextScan(fid, '%q %q\n', 1, 'CommentStyle', ar.config.comment_string);</span>
        arValidateInput(C, <span class="string">'REACTIONS'</span>, <span class="string">'reaction rate expression'</span> );
        str = C(1);
        <span class="keyword">if</span> ( ~isempty(C{2}) )
            ar.model(m).v{end+1} = cell2mat(C{2});
        <span class="keyword">else</span>
            ar.model(m).v{end+1} = sprintf(<span class="string">'v_%d'</span>, length(ar.model(m).v) );
        <span class="keyword">end</span>

        ar.model(m).fv_ma_reverse_pbasename{end+1} = <span class="string">''</span>;
        <span class="keyword">if</span>(~massaction)
            <span class="keyword">if</span>(reversible)
                warning(<span class="string">'Reversible reactions for type CUSTOM in experimental phase. Proceed with caution!'</span>);
            <span class="keyword">end</span>
            ar.model(m).fv(end+1,1) = str{1};

            <span class="comment">% check for negative fluxes possible</span>
            <span class="keyword">if</span>(ar.config.checkForNegFluxes)
                <span class="keyword">if</span> (~reversible)
                    <span class="keyword">try</span>
                        symtmp = sym(str{1});
                    <span class="keyword">catch</span>
                        <span class="keyword">if</span> ( iscell( str{1} ) )
                            arParsingError( fid,  <span class="string">'Parsing error in REACTIONS at %s in model %d'</span>, str{1}{:}, m );
                        <span class="keyword">else</span>
                            arParsingError( fid,  <span class="string">'Parsing error in REACTIONS at %s in model %d'</span>, str{1}, m );
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                    <span class="keyword">for</span> j=1:length(source)
                        symtmpsubs = subs(symtmp, sym(source{j}), 0);
                        <span class="keyword">if</span>(symtmpsubs~=0)
                            arFprintf(1, 2, <span class="string">'Possible negative flux in reaction #%i:\n'</span>, length(ar.model(m).fv));
                            arFprintf(1, 2, <span class="string">'%s : %s\n'</span>, arAssembleReactionStr(source, target, false, sourceCoeffs, targetCoeffs), cell2mat(str{1}));
                            arFprintf(1, 2, <span class="string">'Source species %s missing ?\n\n'</span>, source{j});
                            arFprintf(1, 2, <span class="string">'Deactivate this error message with: ar.config.checkForNegFluxes = false;\n\n'</span>);
                            arParsingError( fid, <span class="string">'Possible negative fluxes in reaction'</span>);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    symtmp = sym(str{1});
                    <span class="keyword">for</span> j=1:length(source)
                        symtmpsubs = subs(symtmp, sym(source{j}), 0);
                        <span class="keyword">for</span> k=1:length(target)
                            symtmpsubs = subs(symtmpsubs, sym(target{k}), 0);
                        <span class="keyword">end</span>

                        <span class="keyword">if</span>(symtmpsubs~=0)
                            arFprintf(1, 2, <span class="string">'Possible flux in reaction without presence of source #%i:\n'</span>, length(ar.model(m).fv));
                            arFprintf(1, 2, <span class="string">'%s : %s\n'</span>, arAssembleReactionStr(source, target, false, sourceCoeffs, targetCoeffs), cell2mat(str{1}));
                            arFprintf(1, 2, <span class="string">'Source species %s missing ?\n\n'</span>, source{j});
                            arFprintf(1, 2, <span class="string">'Deactivate this error message with: ar.config.checkForNegFluxes = false;\n\n'</span>);
                            warning(<span class="string">'Possible erroneous fluxes in reaction'</span>);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                    <span class="keyword">for</span> j=1:length(target)
                        symtmpsubs = subs(symtmp, sym(target{j}), 0);
                        <span class="keyword">for</span> k=1:length(source)
                            symtmpsubs = subs(symtmpsubs, sym(source{k}), 0);
                        <span class="keyword">end</span>

                        <span class="keyword">if</span>(symtmpsubs~=0)
                            arFprintf(1, 2, <span class="string">'Possible flux in reaction without presence of product #%i:\n'</span>, length(ar.model(m).fv));
                            arFprintf(1, 2, <span class="string">'%s : %s\n'</span>, arAssembleReactionStr(source, target, false, sourceCoeffs, targetCoeffs), cell2mat(str{1}));
                            arFprintf(1, 2, <span class="string">'Product species %s missing ?\n\n'</span>, target{j});
                            arFprintf(1, 2, <span class="string">'Deactivate this error message with: ar.config.checkForNegFluxes = false;\n\n'</span>);
                            warning(<span class="string">'Possible erroneous fluxes in reaction'</span>);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            <span class="keyword">if</span>(~reversible)
                ar.model(m).fv{end+1,1} = cell2mat(str{1});
                <span class="keyword">for</span> j=1:length(source)
                    <span class="keyword">if</span> ( sourceCoeffs ~= 1 )
                        ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} <span class="string">'*'</span> source{j} <span class="string">'^'</span> num2str(sourceCoeffs(j))];
                    <span class="keyword">else</span>
                        ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} <span class="string">'*'</span> source{j} ];
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="keyword">if</span>(massactionkd)
                    ar.model(m).fv{end+1,1} = [cell2mat(str{1}) <span class="string">'_1*'</span> cell2mat(str{1}) <span class="string">'_2'</span>];
                <span class="keyword">else</span>
                    ar.model(m).fv{end+1,1} = [cell2mat(str{1}) <span class="string">'_1'</span>];
                <span class="keyword">end</span>
                ar.model(m).fv_ma_reverse_pbasename{end} = cell2mat(str{1});
                <span class="keyword">for</span> j=1:length(source)
                    <span class="keyword">if</span> ( sourceCoeffs ~= 1 )
                        ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} <span class="string">'*'</span> source{j} <span class="string">'^'</span> num2str(sourceCoeffs(j))];
                    <span class="keyword">else</span>
                        ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} <span class="string">'*'</span> source{j} ];
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% setup N</span>
        ar.model(m).N(1:length(ar.model(m).x),vcount) = 0;
        <span class="keyword">for</span> jj=1:length(source)
            <span class="keyword">for</span> j=find(ismember(ar.model(m).x, source{jj})) <span class="comment">%R2013a compatible</span>
                ar.model(m).N(j, vcount) = ar.model(m).N(j, vcount) - sourceCoeffs(jj);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">for</span> jj=1:length(target)
            <span class="keyword">for</span> j=find(ismember(ar.model(m).x, target{jj})) <span class="comment">%R2013a compatible</span>
                ar.model(m).N(j, vcount) = ar.model(m).N(j, vcount) + targetCoeffs(jj);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        ar.model(m).fv_source{end+1,1} = source;
        ar.model(m).fv_target{end+1,1} = target;
        ar.model(m).fv_sourceCoeffs{end+1,1} = sourceCoeffs;
        ar.model(m).fv_targetCoeffs{end+1,1} = targetCoeffs;

        <span class="comment">% check for inconsistent educt compartments</span>
        <span class="keyword">if</span>(~isempty(ar.model(m).c) &amp;&amp; ~ar.model(m).isAmountBased)
            <span class="keyword">for</span> j=1:size(ar.model(m).N,2)
                <span class="keyword">if</span>(length(unique(ar.model(m).cLink(ar.model(m).N(:,j)&gt;0)))&gt;1)
                    arParsingError( fid, <span class="string">'efflux from different compartments in reaction %s'</span>, <span class="keyword">...</span>
                        ar.model(m).fv{end});
                <span class="keyword">end</span>
                <span class="keyword">if</span>(length(unique(ar.model(m).cLink(ar.model(m).N(:,j)&lt;0)))&gt;1)
                    arParsingError( fid, <span class="string">'influx from different compartments in reaction %s'</span>, <span class="keyword">...</span>
                        ar.model(m).fv{end});
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        vcount = vcount + 1;

        <span class="comment">% setup reversed reaction</span>
        <span class="keyword">if</span>(massaction &amp;&amp; reversible)
            ar.model(m).fv{end+1,1} = [cell2mat(str{1}) <span class="string">'_2'</span>];
            ar.model(m).fv_source{end+1,1} = ar.model(m).fv_target{end,1};
            ar.model(m).fv_target{end+1,1} = ar.model(m).fv_source{end,1};
            ar.model(m).fv_ma_reverse_pbasename{end+1} = cell2mat(str{1});
            <span class="keyword">for</span> j=1:length(target)
                <span class="keyword">if</span> ( targetCoeffs(j) ~= 1 )
                    ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} <span class="string">'*'</span> target{j} <span class="string">'^'</span> num2str(targetCoeffs(j))];
                <span class="keyword">else</span>
                    ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} <span class="string">'*'</span> target{j}];
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% infer flux units</span>
            <span class="keyword">if</span>(~isempty(target))
                ix = find(ismember(ar.model(m).x, target{1})); <span class="comment">%R2013a compatible</span>
            <span class="keyword">elseif</span>(~isempty(source))
                ix = find(ismember(ar.model(m).x, source{1})); <span class="comment">%R2013a compatible</span>
            <span class="keyword">else</span>
                arParsingError( fid, <span class="string">'reaction with empty N'</span>);
            <span class="keyword">end</span>
            ar.model(m).vUnits{end+1,1} = [ar.model(m).xUnits{ix,1} <span class="string">'/'</span> ar.model(m).tUnits{1}];
            ar.model(m).vUnits{end,2} = [ar.model(m).xUnits{ix,2} <span class="string">'/'</span> ar.model(m).tUnits{2}];
            ar.model(m).vUnits{end,3} = [ar.model(m).xUnits{ix,3} <span class="string">'/'</span> ar.model(m).tUnits{3}];
            ar.model(m).v{end+1} = cell2mat(C{2});

            <span class="comment">% setup N</span>
            ar.model(m).N(1:length(ar.model(m).x),vcount) = 0;
            <span class="keyword">for</span> jj=1:length(source)
                <span class="keyword">for</span> j=find(ismember(ar.model(m).x, source{jj})) <span class="comment">%R2013a compatible</span>
                    ar.model(m).N(j, vcount) = ar.model(m).N(j, vcount) + sourceCoeffs(jj);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">for</span> jj=1:length(target)
                <span class="keyword">for</span> j=find(ismember(ar.model(m).x, target{jj})) <span class="comment">%R2013a compatible</span>
                    ar.model(m).N(j, vcount) = ar.model(m).N(j, vcount) - targetCoeffs(jj);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% check for inconsistent educt compartments</span>
            <span class="keyword">if</span>(~isempty(ar.model(m).c))
                <span class="keyword">for</span> j=1:size(ar.model(m).N,2)
                    <span class="keyword">if</span>(length(unique(ar.model(m).cLink(ar.model(m).N(:,j)&gt;0)))&gt;1)
                        arParsingError( fid, <span class="string">'efflux from different compartments in reaction %s'</span>, <span class="keyword">...</span>
                            ar.model(m).fv{end});
                    <span class="keyword">end</span>
                    <span class="keyword">if</span>(length(unique(ar.model(m).cLink(ar.model(m).N(:,j)&lt;0)))&gt;1)
                        arParsingError( fid, <span class="string">'influx from different compartments in reaction %s'</span>, <span class="keyword">...</span>
                            ar.model(m).fv{end});
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            vcount = vcount + 1;
        <span class="keyword">end</span>

        <span class="comment">%str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);</span>
        <span class="comment">% No string left? Grab a new one</span>

        <span class="comment">%if delayCh.ctr == 1</span>
            <span class="comment">%[ line, remainder, fid ] = readLine( fid, ar.config.comment_string );</span>
            <span class="keyword">if</span> ~isempty(regexp(line, <span class="string">'-\d-&gt;'</span>))
                delayCh.enterDel = 1;
                <span class="comment">%delayCh.ctr = delayCh.ctr + 1;</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> delayCh.enterDel == 1 &amp; delayCh.ctr &lt; delayCh.length
            <span class="comment">%if delayCh.ctr &gt; 1 &amp;&amp; delayCh.ctr &lt; delayCh.length</span>
            line = sprintf(<span class="string">'Delay_%02d -&gt; Delay_%02d CUSTOM "k_delay*Delay_%02d"'</span>,<span class="keyword">...</span>
                delayCh.ctr, delayCh.ctr+1, delayCh.ctr);
            remainder = line;
            delayCh.ctr = delayCh.ctr + 1; <span class="comment">%es wird gar keine neue line</span>
            <span class="comment">%geladen also greift immer erste if clause</span>
            <span class="keyword">end</span>
            <span class="comment">%[ line, remainder, fid ] = readLine( fid, ar.config.comment_string );</span>
        <span class="comment">%end %nach unten setzen?</span>

        <span class="keyword">if</span> isempty( remainder )
            <span class="keyword">if</span> delayCh.ctr &gt;= delayCh.length | delayCh.ctr == 1
            [ line, remainder, fid ] = readLine( fid, ar.config.comment_string );
            <span class="keyword">end</span>
        <span class="keyword">end</span>


        [str, remainder] = grabtoken( remainder, <span class="string">'%s'</span>, 1 );
    <span class="keyword">end</span>
<span class="keyword">elseif</span>(strcmp(C{1},<span class="string">'ODES'</span>))
    ar.model(m).isReactionBased = false;
    [str, fid] = arTextScan(fid, <span class="string">'%q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
    ode_count = 0;
    <span class="keyword">while</span>(~strcmp(str{1},<span class="string">'INVARIANTS'</span>) &amp;&amp; ~strcmp(str{1},<span class="string">'DERIVED'</span>))
        <span class="keyword">if</span>(~strcmp(str{1},<span class="string">''</span>))
            ode_count = ode_count + 1;
            ar.model(m).fv{end+1,1} = cell2mat(str{1});
            ar.model(m).fv_ma_reverse_pbasename{end+1} = <span class="string">''</span>;
            ar.model(m).vUnits{end+1,1} = [ar.model(m).xUnits{ode_count,1} <span class="string">'/'</span> ar.model(m).tUnits{1}];
            ar.model(m).vUnits{end,2} = [ar.model(m).xUnits{ode_count,2} <span class="string">'/'</span> ar.model(m).tUnits{2}];
            ar.model(m).vUnits{end,3} = [ar.model(m).xUnits{ode_count,3} <span class="string">'/'</span> ar.model(m).tUnits{3}];
        <span class="keyword">end</span>
        [str, fid] = arTextScan(fid, <span class="string">'%q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
    <span class="keyword">end</span>
    <span class="keyword">if</span>(ode_count ~= length(ar.model(m).x))
        arParsingError( fid, <span class="string">'number of ODES ~= number of variables'</span>);
    <span class="keyword">end</span>
    ar.model(m).N = eye(length(ar.model(m).x));
<span class="keyword">end</span>
ar.model(m).qPlotV = ones(1,length(ar.model(m).fv));
<span class="keyword">if</span>(isempty(ar.model(m).fv))
    ar.model(m).isReactionBased = false;
<span class="keyword">end</span>

<span class="comment">% dynamic parameters</span>
ar.model(m).pvs = cell(size(ar.model(m).fv));
ar.model(m).pv = {};
<span class="keyword">for</span> jv=1:length(ar.model(m).fv)
    varlist = symvar(ar.model(m).fv{jv});
    ar.model(m).pvs{jv} = setdiff(varlist, union(ar.model(m).t, union(ar.model(m).x, ar.model(m).u))); <span class="comment">%R2013a compatible</span>
    ar.model(m).pv = union(ar.model(m).pv, ar.model(m).pvs{jv});
<span class="keyword">end</span>
ar.model(m).px = union(union(ar.model(m).pv, ar.model(m).px), ar.model(m).px0); <span class="comment">%R2013a compatible</span>
ar.model(m).p = union(ar.model(m).px, ar.model(m).pu); <span class="comment">%R2013a compatible</span>

<span class="comment">% setup rhs</span>
C = cell(size(ar.model(m).N));
C_par = cell(size(ar.model(m).N));
<span class="keyword">if</span>(length(ar.model(m).c)&gt;1)
    <span class="keyword">if</span>(~isfield(ar.model(m),<span class="string">'isAmountBased'</span>) || ~ar.model(m).isAmountBased)
        <span class="keyword">for</span> j=1:size(ar.model(m).N,1) <span class="comment">% for every species j</span>
            qinfluxwitheducts = ar.model(m).N(j,:) &gt; 0 &amp; sum(ar.model(m).N &lt; 0,1) &gt; 0;
            eductcompartment = zeros(size(qinfluxwitheducts));
            <span class="keyword">for</span> jj=find(qinfluxwitheducts)
				eductcompartment(jj) = unique(ar.model(m).cLink(ar.model(m).N(:,jj)&lt;0)); <span class="comment">%R2013a compatible</span>
            <span class="keyword">end</span>

            cfaktor = cell(size(qinfluxwitheducts));
            cfaktor_par = cell(size(qinfluxwitheducts));
            <span class="keyword">for</span> jj=1:size(ar.model(m).N,2) <span class="comment">% for every reaction jj</span>
                <span class="keyword">if</span>(qinfluxwitheducts(jj) &amp;&amp; eductcompartment(jj)~=ar.model(m).cLink(j))
                    cfaktor{jj} = [ar.model(m).pc{eductcompartment(jj)} <span class="string">'/'</span> <span class="keyword">...</span>
                        ar.model(m).pc{ar.model(m).cLink(j)}];
                    cfaktor_par{jj} = [ar.model(m).c{eductcompartment(jj)} <span class="string">'/'</span> <span class="keyword">...</span>
                        ar.model(m).c{ar.model(m).cLink(j)}];
                <span class="keyword">else</span>
                    cfaktor{jj} = <span class="string">'1'</span>;
                    cfaktor_par{jj} = <span class="string">'1'</span>;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            C(j,:) = transpose(cfaktor);
            C_par(j,:) = transpose(cfaktor_par);
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">for</span> j=1:size(ar.model(m).N,1) <span class="comment">% for every species j</span>
            <span class="keyword">for</span> jj=1:size(ar.model(m).N,2) <span class="comment">% for every reaction jj</span>
                C{j,jj} = [<span class="string">'1/'</span> ar.model(m).pc{ar.model(m).cLink(j)}];
                C_par{j,jj} = [<span class="string">'1/'</span> ar.model(m).c{ar.model(m).cLink(j)}];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    <span class="keyword">for</span> j=1:size(ar.model(m).N,1) <span class="comment">% for every species j</span>
        <span class="keyword">for</span> jj=1:size(ar.model(m).N,2) <span class="comment">% for every reaction jj</span>
            C{j,jj} = <span class="string">'1'</span>;
            C_par{j,jj} = <span class="string">'1'</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
ar.model(m).fx = cell(length(ar.model(m).x),1);
ar.model(m).fx_par = cell(length(ar.model(m).x),1);

<span class="comment">% initialize symbolic variables</span>
<span class="comment">% Joep: I have removed this. Not sure if this serves any purpose? Removing</span>
<span class="comment">% it seems to not affect any of the integration tests.</span>
<span class="comment">%if(~isempty(ar.model(m).x))</span>
<span class="comment">%    eval(['syms ' sprintf('%s ',ar.model(m).x{:})]);</span>
<span class="comment">%end</span>
<span class="comment">%if(~isempty(ar.model(m).p))</span>
<span class="comment">%    eval(['syms ' sprintf('%s ',ar.model(m).p{:})]);</span>
<span class="comment">%end</span>
<span class="comment">%if(~isempty(ar.model(m).u))</span>
<span class="comment">%    eval(['syms ' sprintf('%s ',ar.model(m).u{:})]);</span>
<span class="comment">%end</span>
ar.model(m).Cm = C;
ar.model(m).Cm_par = C_par;
tmpfx = (sym(ar.model(m).N).*sym(C)) * sym(ar.model(m).fv);
tmpfx_par = (sym(ar.model(m).N).*sym(C_par)) * sym(ar.model(m).fv);

<span class="keyword">for</span> j=1:length(ar.model(m).x) <span class="comment">% for every species j</span>
    <span class="keyword">if</span> ~isempty(tmpfx)
        ar.model(m).fx{j} = char(tmpfx(j));
        ar.model(m).fx_par{j} = char(tmpfx_par(j));
    <span class="keyword">else</span>
        ar.model(m).fx{j} = char(<span class="string">'0'</span>);
        ar.model(m).fx_par{j} = char(<span class="string">'0'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">% DERIVED (previously INVARIANTS)</span>
<span class="keyword">if</span>(strcmp(str{1},<span class="string">'INVARIANTS'</span>))
    arParsingError( fid, [<span class="string">'Section INVARIANTS in model definition file is deprecated! '</span> <span class="keyword">...</span>
        <span class="string">'Please replace by DERIVED and see usage in: '</span> <span class="keyword">...</span>
        <span class="string">'https://github.com/Data2Dynamics/d2d/wiki/Setting%20up%20models'</span>]);
<span class="keyword">end</span>
derivedVariablesInRates = 0;
ar.model(m).z = {};
ar.model(m).zUnits = {};
ar.model(m).fz = {};
[C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">while</span>(~strcmp(C{1},<span class="string">'CONDITIONS'</span>) &amp;&amp; ~strcmp(C{1},<span class="string">'SUBSTITUTIONS'</span>) &amp;&amp; ~strcmp(C{1},<span class="string">'OBSERVABLES'</span>))
    <span class="keyword">if</span>(~strcmp(C{1},<span class="string">''</span>))
        arValidateInput( C, <span class="string">'derived'</span>, <span class="string">'unique identifier'</span>, <span class="string">'unit type (i.e. C)'</span>, <span class="string">'unit (i.e. "units/cell")'</span>, <span class="string">'plain text label for plots ("conc.")'</span>, <span class="string">'derived function expression'</span> );
        <span class="keyword">if</span>(sum(ismember(ar.model(m).x, C{1}))&gt;0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'derived variable %s already defined in STATES'</span>, cell2mat(C{1}));
        <span class="keyword">end</span>
        <span class="keyword">if</span>(sum(ismember(ar.model(m).u, C{1}))&gt;0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'derived variable %s already defined in INPUTS'</span>, cell2mat(C{1}));
        <span class="keyword">end</span>
        <span class="comment">% Found derived variable in parameter list. See if it is used in</span>
        <span class="comment">% either the inputs or the reaction equations. If the former, fail</span>
        <span class="comment">% the loading, since we cannot resolve the state values at the time</span>
        <span class="comment">% the inputs are computed. If the latter =&gt; substitute them in!</span>
        <span class="keyword">if</span>(sum(ismember(ar.model(m).p, C{1}))&gt;0) <span class="comment">%R2013a compatible</span>
            ar.model(m).p(ismember(ar.model(m).p, C{1})) = [];
            derivedVariablesInRates = 1;
            fail = 0;
            inputVariables = cellfun(@symvar, ar.model(m).fu, <span class="string">'UniformOutput'</span>, false);
            <span class="keyword">for</span> ju = 1 : length( inputVariables )
                fail = fail | max( ismember( inputVariables{ju}, C{1} ) );
            <span class="keyword">end</span>
            <span class="keyword">if</span> ( fail )
                arParsingError( fid, <span class="string">'derived variable %s already defined as parameter in INPUT section'</span>, cell2mat(C{1}));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        ar.model(m).z(end+1) = C{1};
        ar.model(m).zUnits(end+1,1) = C{2};
        ar.model(m).zUnits(end,2) = C{3};
        ar.model(m).zUnits(end,3) = C{4};
        ar.model(m).fz(end+1,1) = C{5};
    <span class="keyword">end</span>
    [C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">end</span>

<span class="comment">% Perform (repeated) derived substitutions</span>
<span class="keyword">if</span> ( derivedVariablesInRates )
    <span class="keyword">for</span> a = 1 : length( ar.model(m).fv )
        ar.model(m).fv{a} = char( arSubsRepeated(sym(ar.model(m).fv{a}), ar.model(m).z, ar.model(m).fz, matVer.Version) );
    <span class="keyword">end</span>
    arFprintf(2, <span class="string">'=&gt; Substituting derived variables in reaction equation.\n'</span> );
<span class="keyword">end</span>


ar.model(m).qPlotZ = ones(size(ar.model(m).z));

<span class="comment">% derived variables parameters</span>
varlist = cellfun(@symvar, ar.model(m).fz, <span class="string">'UniformOutput'</span>, false);
ar.model(m).pz = setdiff(setdiff(vertcat(varlist{:}), {ar.model(m).t, <span class="string">''</span>}), union(ar.model(m).x, union(ar.model(m).u, ar.model(m).z))); <span class="comment">%R2013a compatible</span>
ar.model(m).px = union(ar.model(m).px, ar.model(m).pz); <span class="comment">%R2013a compatible</span>
ar.model(m).p = union(ar.model(m).p, ar.model(m).pz); <span class="comment">%R2013a compatible</span>


<span class="keyword">if</span>(strcmp(C{1},<span class="string">'OBSERVABLES'</span>))

    <span class="comment">% OBSERVABLES</span>
    ar.model(m).y = {};
    ar.model(m).yNames = {};
    ar.model(m).yUnits = {};
    ar.model(m).normalize = [];
    ar.model(m).logfitting = [];
    ar.model(m).logplotting = [];
    ar.model(m).fy = {};
    [C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %n %n %q %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
    <span class="keyword">while</span>(~strcmp(C{1},<span class="string">'ERRORS'</span>))
        <span class="keyword">if</span> ( strcmp( C{1}, <span class="string">'CONDITIONS'</span> ) || strcmp( C{1}, <span class="string">'SUBSTITUTIONS'</span> ) )
            arParsingError( fid,  <span class="string">'When OBSERVABLES section is specified; ERRORS section must also be specified.'</span> );
        <span class="keyword">end</span>
        arValidateInput( C, <span class="string">'observable'</span>, <span class="string">'unique identifier'</span>, <span class="string">'unit type (i.e. C)'</span>, <span class="string">'unit (i.e. "units/cell")'</span>, <span class="string">'plain text label for plots ("conc.")'</span>, <span class="string">'indicator whether data should be scaled to 1 (0 or 1)'</span>, <span class="string">'Indicator whether date should be treated in log-space (0 or 1)'</span>, <span class="string">'Mathematical expression for observable'</span> );
        ar.model(m).y(end+1) = C{1};
        ar.model(m).yUnits(end+1,1) = C{2};
        ar.model(m).yUnits(end,2) = C{3};
        ar.model(m).yUnits(end,3) = C{4};
        ar.model(m).normalize(end+1) = C{5};
        ar.model(m).logfitting(end+1) = C{6};
        ar.model(m).logplotting(end+1) = C{6};
        ar.model(m).fy(end+1,1) = C{7};
        <span class="keyword">if</span>(~isempty(cell2mat(C{8})))
            ar.model(m).yNames(end+1) = C{8};
        <span class="keyword">else</span>
            ar.model(m).yNames(end+1) = ar.model(m).y(end);
        <span class="keyword">end</span>
        [C, fid] = arTextScan(fid, <span class="string">'%s %q %q %q %n %n %q %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
        <span class="keyword">if</span>(sum(ismember(ar.model(m).x, ar.model(m).y{end}))&gt;0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'%s already defined in STATES'</span>, ar.model(m).y{end});
        <span class="keyword">end</span>
        <span class="keyword">if</span>(sum(ismember(ar.model(m).u, ar.model(m).y{end}))&gt;0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'%s already defined in INPUTS'</span>, ar.model(m).y{end});
        <span class="keyword">end</span>
        <span class="keyword">if</span>(sum(ismember(ar.model(m).z, ar.model(m).y{end}))&gt;0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'%s already defined in DERIVED'</span>, ar.model(m).y{end});
        <span class="keyword">end</span>
        <span class="keyword">if</span>(sum(ismember(ar.model(m).p, ar.model(m).y{end}))&gt;0) <span class="comment">%R2013a compatible</span>
            arParsingError( fid, <span class="string">'%s already defined as parameter'</span>, ar.model(m).y{end});
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% observation parameters</span>
    varlist = cellfun(@symvar, ar.model(m).fy, <span class="string">'UniformOutput'</span>, false);
    ar.model(m).py = setdiff(setdiff(vertcat(varlist{:}), union(union(union(ar.model(m).x, ar.model(m).u), ar.model(m).z), ar.model(m).z)), {ar.model(m).t, <span class="string">''</span>}); <span class="comment">%R2013a compatible</span>

    <span class="comment">% ERRORS</span>
    ar.model(m).fystd = cell(size(ar.model(m).fy));
    [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
    <span class="keyword">while</span>(~(strcmp(C{1},<span class="string">'CONDITIONS'</span>) || strcmp(C{1},<span class="string">'SUBSTITUTIONS'</span>)))
        qy = ismember(ar.model(m).y, C{1}); <span class="comment">%R2013a compatible</span>

        <span class="keyword">if</span>(sum(qy)&lt;1)
            arParsingError( fid, <span class="string">'Unknown observable in error specification %s.'</span>, cell2mat(C{1}));
        <span class="keyword">elseif</span> sum(qy)&gt;1
            arParsingError( fid, <span class="string">'Observable %s seems to occur more than once.'</span>, cell2mat(C{1}));
        <span class="keyword">end</span>

        <span class="comment">%check and error if observable in log and fystd = rel + abs error</span>
        y_var_name = setdiff(symvar(ar.model(m).fy{qy}),ar.model(m).py);
        reg_string = [<span class="string">'((?&lt;=\W)|^)('</span>,C{1}{1},<span class="string">'|'</span>];
        <span class="keyword">for</span> jreg = 1:length(y_var_name)
            <span class="keyword">if</span>(jreg&lt;length(y_var_name))
                reg_string = [reg_string ,y_var_name{jreg},<span class="string">'|'</span>];
            <span class="keyword">else</span>
                reg_string = [reg_string ,y_var_name{jreg},<span class="string">')'</span>];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        reg_string = [reg_string <span class="string">'((?=\W)|$)'</span>];
        <span class="keyword">if</span>(~isempty(regexp(C{2}{1},reg_string,<span class="string">'ONCE'</span>)) &amp;&amp; ar.model(m).logfitting(qy))
            warning([<span class="string">'You are trying to set up a relative error model within a log transformation. \n%s'</span> <span class="keyword">...</span>
            <span class="string">'Comment out this error if you want to proceed anyway. To implement an absolute error in log, \n'</span> <span class="keyword">...</span>
            <span class="string">'you can try the approach: \nyObs = sd_yObs + 1/2 * (a+sqrt((a)^2)), a = (offset - yObs-sd_yObs) \n, with hard set or fitted offset (on log-scale) \n'</span>],C{2}{1})
            arParsingError( fid, <span class="string">'Revise error model'</span>)
        <span class="keyword">end</span>
        arValidateInput( C, <span class="string">'error'</span>, <span class="string">'observable identifier'</span>, <span class="string">'expression for the error model'</span> );

        ar.model(m).fystd(qy) = C{2};
        [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
        <span class="keyword">if</span> ( isempty( C{1} ) )
            arParsingError( fid,  <span class="string">'Missing field CONDITIONS'</span> );
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> (length(ar.model(m).fystd)&lt;length(ar.model(m).fy) || sum(cellfun(@isempty, ar.model(m).fystd))&gt;0)
        diffErr = ar.model(m).y(cellfun(@isempty, ar.model(m).fystd)&gt;0);
        <span class="keyword">if</span> ( length(ar.model(m).fystd)&lt;length(ar.model(m).fy) )
            diffErr = union( ar.model(m).y( length(ar.model(m).fystd) + 1 : end ), diffErr );
        <span class="keyword">end</span>

        arParsingError( fid, <span class="string">'Some observables do not have an error model defined. Observable(s) without error model: %s\n'</span>, sprintf( <span class="string">'%s '</span>, diffErr{:} ) );
    <span class="keyword">end</span>

    <span class="comment">% error parameters</span>
    varlist = cellfun(@symvar, ar.model(m).fystd, <span class="string">'UniformOutput'</span>, false);
    ar.model(m).pystd = setdiff(vertcat(varlist{:}), union(union(union(union(union(ar.model(m).x, ar.model(m).u), ar.model(m).z), <span class="keyword">...</span><span class="comment"> %R2013a compatible</span>
        ar.model(m).z), ar.model(m).y), ar.model(m).t));

    <span class="comment">% add to parameters needed for model</span>
    ar.model(m).p = union(union(ar.model(m).p, ar.model(m).py), ar.model(m).pystd);
<span class="keyword">end</span>

<span class="comment">% SUBSTITUTIONS (beta)</span>
substitutions = 0;
<span class="keyword">if</span> ( strcmp(C{1},<span class="string">'SUBSTITUTIONS'</span>) )
    <span class="keyword">if</span>(str2double(matVer.Version)&gt;=8.4)
        [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
    <span class="keyword">else</span>
        [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string, <span class="string">'BufSize'</span>, 2^16);
    <span class="keyword">end</span>

    <span class="comment">% Substitutions</span>
    fromSubs = {};
    toSubs = {};
    ismodelpar = [];

    <span class="comment">% Fetch desired substitutions</span>
    <span class="keyword">while</span>(~isempty(C{1}) &amp;&amp; ~strcmp(C{1},<span class="string">'CONDITIONS'</span>))
        fromSubs(end+1)     = C{1}; <span class="comment">%#ok&lt;AGROW&gt;</span>
        toSubs(end+1)       = C{2}; <span class="comment">%#ok&lt;AGROW&gt;</span>
        ismodelpar(end+1)   = sum(ismember(ar.model(m).p, C{1})); <span class="comment">%#ok&lt;AGROW&gt;</span>

        <span class="keyword">if</span>(str2double(matVer.Version)&gt;=8.4)
            [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
        <span class="keyword">else</span>
            [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string, <span class="string">'BufSize'</span>, 2^16-1);
        <span class="keyword">end</span>

        <span class="keyword">if</span> ( ~strcmp(C{1},<span class="string">'CONDITIONS'</span>) )
            arValidateInput( C, <span class="string">'substitution'</span>, <span class="string">'substitution identifier'</span>, <span class="string">'expression for the substitution'</span> );
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> ( sum(ismodelpar) &gt; 0 )
        s = sprintf( <span class="string">'%s\n'</span>, fromSubs{ismodelpar&gt;0} );
        arParsingError( fid,  <span class="string">'Cannot substitute model parameters. These following parameters belong under CONDITIONS:\n%s'</span>, s );
    <span class="keyword">end</span>

    <span class="comment">% Perform selfsubstitutions</span>
    <span class="keyword">if</span> ( ~isempty(fromSubs) )
        substitutions = 1;
        toSubs = arSubsRepeated( toSubs, fromSubs, toSubs, str2double(matVer.Version) );
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">% CONDITIONS</span>
<span class="keyword">if</span>(str2double(matVer.Version)&gt;=8.4)
    [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">else</span>
    [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string, <span class="string">'BufSize'</span>, 2^16);
<span class="keyword">end</span>
ar.model(m).fp = transpose(ar.model(m).p);

<span class="keyword">if</span> ( substitutions )
	<span class="comment">% Conditions</span>
    from        = {};
    to          = {};
    ismodelpar  = [];

    <span class="comment">% Fetch desired conditions</span>
    <span class="keyword">while</span>(~isempty(C{1}) &amp;&amp; ~(strcmp(C{1},<span class="string">'PARAMETERS'</span>) || strcmp(C{1}, <span class="string">'RANDOM'</span>)))
        arValidateInput( C, <span class="string">'condition'</span>, <span class="string">'model parameter'</span>, <span class="string">'new expression'</span> );
        from(end+1)         = C{1}; <span class="comment">%#ok&lt;AGROW&gt;</span>
        to(end+1)           = C{2}; <span class="comment">%#ok&lt;AGROW&gt;</span>
        ismodelpar(end+1)   = sum(ismember(ar.model(m).p, C{1})); <span class="comment">%#ok&lt;AGROW&gt;</span>

        <span class="keyword">if</span>(str2double(matVer.Version)&gt;=8.4)
            [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
        <span class="keyword">else</span>
            [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string, <span class="string">'BufSize'</span>, 2^16-1);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Extra conditions specified at compile time</span>
    <span class="keyword">if</span> ( opts.conditions )
        <span class="keyword">for</span> a = 1 : length( opts.conditions_args )
            from(end+1)         = opts.conditions_args{a,1}; <span class="comment">%#ok&lt;AGROW&gt;</span>
            to(end+1)           = opts.conditions_args{a,2}; <span class="comment">%#ok&lt;AGROW&gt;</span>
            ismodelpar(end+1)   = sum(ismember(ar.model(m).p, from(end))); <span class="comment">%#ok&lt;AGROW&gt;</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Perform substitutions (self-substitutions were already done)</span>
    to = arSubsRepeated( to, fromSubs, toSubs, str2double(matVer.Version) );

    <span class="comment">% Store substitutions in ar structure</span>
    <span class="keyword">for</span> a = 1 : length( from )
        qcondpara = ismember(ar.model(m).p, from{a}); <span class="comment">%R2013a compatible</span>
        <span class="keyword">if</span>(sum(qcondpara)&gt;0)
            ar.model(m).fp{qcondpara} = [<span class="string">'('</span> to{a} <span class="string">')'</span>];
        <span class="keyword">else</span>
            warning(<span class="string">'unknown parameter in conditions: %s (did you mean to place it under SUBSTITUTIONS?)'</span>, from{a}); <span class="comment">%#ok&lt;WNTAG&gt;</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    <span class="comment">% Old code path</span>
    <span class="keyword">while</span>(~isempty(C{1}) &amp;&amp; ~(strcmp(C{1},<span class="string">'PARAMETERS'</span>) || strcmp(C{1}, <span class="string">'RANDOM'</span>)))
        arValidateInput( C, <span class="string">'condition'</span>, <span class="string">'model parameter'</span>, <span class="string">'new expression'</span> );
        qcondpara = ismember(ar.model(m).p, C{1}); <span class="comment">%R2013a compatible</span>
        <span class="keyword">if</span>(sum(qcondpara)&gt;0)
            ar.model(m).fp{qcondpara} = [<span class="string">'('</span> cell2mat(C{2}) <span class="string">')'</span>];
        <span class="keyword">else</span>
            warning(<span class="string">'unknown parameter in conditions: %s (did you mean to place it under SUBSTITUTIONS?)'</span>, cell2mat(C{1})); <span class="comment">%#ok&lt;WNTAG&gt;</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span>(str2double(matVer.Version)&gt;=8.4)
            [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
        <span class="keyword">else</span>
            [C, fid] = arTextScan(fid, <span class="string">'%s %q\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string, <span class="string">'BufSize'</span>, 2^16-1);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

ar.model(m).prand = {};
ar.model(m).rand_type = [];
<span class="keyword">if</span> ( strcmp(C{1}, <span class="string">'RANDOM'</span> ) )
    [C, fid] = arTextScan(fid, <span class="string">'%s %s\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
    <span class="keyword">while</span>(~isempty(C{1}) &amp;&amp; ~strcmp(C{1},<span class="string">'PARAMETERS'</span>))
        ar.model(m).prand{end+1} = cell2mat(C{1});
        <span class="keyword">if</span>(strcmp(C{2}, <span class="string">'INDEPENDENT'</span>))
            ar.model(m).rand_type(end+1) = 0;
        <span class="keyword">elseif</span>(strcmp(C{2}, <span class="string">'NORMAL'</span>))
            ar.model(m).rand_type(end+1) = 1;
        <span class="keyword">else</span>
            warning(<span class="string">'unknown random type %s'</span>, cell2mat(C{2}));  <span class="comment">%#ok&lt;WNTAG&gt;</span>
        <span class="keyword">end</span>
        [C, fid] = arTextScan(fid, <span class="string">'%s %s\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% extra conditional parameters</span>
varlist = cellfun(@symvar, ar.model(m).fp, <span class="string">'UniformOutput'</span>, false);
ar.model(m).pcond = setdiff(setdiff(setdiff(vertcat(varlist{:}), ar.model(m).p), ar.model(m).x), ar.model(m).u); <span class="comment">%R2013a compatible</span>

<span class="comment">% PARAMETERS</span>
<span class="keyword">if</span>(~isfield(ar, <span class="string">'pExternLabels'</span>))
    ar.pExternLabels = {};
    ar.pExtern = [];
    ar.qFitExtern = [];
    ar.qLog10Extern = [];
    ar.lbExtern = [];
    ar.ubExtern = [];
<span class="keyword">end</span>
[C, fid] = arTextScan(fid, <span class="string">'%s %f %n %n %f %f\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);

<span class="keyword">while</span>(~isempty(C{1}))
    ar.pExternLabels(end+1) = C{1};
    ar.pExtern(end+1) = C{2};
    ar.qFitExtern(end+1) = C{3};
    ar.qLog10Extern(end+1) = C{4};
    ar.lbExtern(end+1) = C{5};
    ar.ubExtern(end+1) = C{6};
    [C, fid] = arTextScan(fid, <span class="string">'%s %f %n %n %f %f\n'</span>,1, <span class="string">'CommentStyle'</span>, ar.config.comment_string);
<span class="keyword">end</span>

<span class="keyword">if</span> ~isstruct( fid )
    fclose(fid);
<span class="keyword">end</span>

<span class="comment">% Check whether the user specified any variables with reserved words. This</span>
<span class="comment">% would be problematic later.</span>
<span class="keyword">for</span> a = 1 : length( ar.model(m).fu )
    arCheckReservedWords( symvar(ar.model(m).fu{a}), <span class="string">'input function'</span>, ar.model(m).u{a} );
<span class="keyword">end</span>
<span class="keyword">if</span> ( isfield( ar.model(m), <span class="string">'fy'</span> ) )
    <span class="keyword">for</span> a = 1 : length( ar.model(m).fy )
        arCheckReservedWords( symvar(ar.model(m).fy{a}), <span class="string">'observation function'</span>, ar.model(m).y{a} );
    <span class="keyword">end</span>
    <span class="keyword">for</span> a = 1 : length( ar.model(m).fystd )
        arCheckReservedWords( symvar(ar.model(m).fystd{a}), <span class="string">'observation standard deviation'</span>, ar.model(m).y{a} );
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ( isfield( ar.model(m), <span class="string">'fp'</span> ) )
    <span class="keyword">for</span> a = 1 : length( ar.model(m).fp )
        arCheckReservedWords( symvar(ar.model(m).fp{a}), <span class="string">'parameter transformation'</span>, ar.model(m).p{a} );
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">for</span> a = 1 : length( ar.model(m).fx )
    arCheckReservedWords( symvar(ar.model(m).fx{a}), <span class="string">'right hand side'</span>, ar.model(m).x{a} );
<span class="keyword">end</span>

arCheckReservedWords( ar.model(m).p, <span class="string">'parameters'</span> );
arCheckReservedWords( ar.model(m).x, <span class="string">'state variables'</span> );
<span class="keyword">if</span> ( isfield( ar.model(m), <span class="string">'y'</span> ) )
    arCheckReservedWords( ar.model(m).y, <span class="string">'observables'</span> );
<span class="keyword">end</span>
<span class="keyword">if</span> ( isfield( ar.model(m), <span class="string">'z'</span> ) )
    arCheckReservedWords( ar.model(m).z, <span class="string">'derived variables'</span> );
<span class="keyword">end</span>
<span class="keyword">if</span> ( isfield( ar.model(m), <span class="string">'u'</span> ) )
    arCheckReservedWords( ar.model(m).u, <span class="string">'inputs'</span> );
<span class="keyword">end</span>
arCheckReservedWords( ar.model(m).c, <span class="string">'compartments'</span> );

ar = orderfields(ar);
ar.model = orderfields(ar.model);


<span class="keyword">function</span> [ line, remainder, fid ] = readLine( fid, commentStyle )
    line = <span class="string">''</span>;
    <span class="keyword">while</span> ( isempty(line) )
        [line, fid] = arTextScan(fid, <span class="string">'%[^\n]'</span> );
        line = strtrim(line{1}{1});
        Q = strfind( line, commentStyle );
        <span class="keyword">if</span> ( ~isempty(Q) )
            line = line(1:Q-1);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    remainder = line;


<span class="keyword">function</span> [str, remainder] = grabtoken( inputString, varargin )
    <span class="keyword">if</span> ( isempty( inputString ) )
        str{1} = {};
        remainder = <span class="string">''</span>;
        <span class="keyword">return</span>;
    <span class="keyword">end</span>

	[str, pos] = textscan(inputString, varargin{:});
	remainder = inputString(pos+1:end);

<span class="keyword">function</span> num = checkNum( num, defaultValue )
    <span class="keyword">if</span> ( ~isnumeric( num ) || isempty( num ) || isnan( num ) )
        num = defaultValue;
    <span class="keyword">end</span>
</pre><pre class="codeoutput error">Not enough input arguments.
Error in arLoadModel (line 32)
if strcmp(strrep(name,' ',''),name)~=1</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
% Load Model definition to next free index position
% 
% arLoadModel(name)
%
% name      filename of model definition file
% m         model index for the model to go into
%
% Copyright Andreas Raue 2011 (andreas.raue@fdm.uni-freiburg.de)

% regexp('test->5->test', '->\d->', 'Match')

function arLoadModel(name, m, varargin)

global ar

if(isempty(ar))
    error('please initialize by arInit')
end

% custom
switches = { 'conditions' };
extraArgs = [ 1 ];
description = { ...
    {'', 'Specified extra conditions'} };
    
opts = argSwitch( switches, extraArgs, description, 1, varargin );

% load model from mat-file
if(~exist('Models','dir'))
    error('folder Models/ does not exist')
end
if strcmp(strrep(name,' ',''),name)~=1
    name
    error('File names should not contain empty spaces. Please remove it.');
end
if(~exist(['Models/' name '.def'],'file'))
    error('model definition file %s.def does not exist in folder Models/', name)
end

if(~exist('m','var'))
    if(isfield(ar, 'model'))
        m = length(ar.model) + 1;
    else
        m = 1;
    end
else
    error(['Usage arLoadModel(name, m) is deprecated. Please use arLoadModel(name) ' ...
        'and note that the model will be loaded to the next free index position by default.']);
end

% Disable this if you are having problems because of the preprocessor
preprocessor = 1;
arFprintf(1, 'loading model #%i, from file Models/%s.def...\n', m, name);
if ( ~preprocessor )
    fid = fopen(['Models/' name '.def'], 'r');
else
    % Load into a struct
    fid.fn  = ['Models/' name '.def'];
    fid.str = fileread(['Models/' name '.def']);
    fid.pos = 1;
    
    fid = arPreProcessor(fid);
end

% initial setup
ar.model(m).name = name;
ar.model(m).path = [pwd,filesep,'Models',filesep];

% Validate input
if ( opts.conditions )
    if ~(size( opts.conditions_args, 2 ) == 2) || ~iscell( opts.conditions_args )
        error( 'Additional conditions should be given in Mx2 cell array.' );
    else
        ar.model(m).extra_conditions = opts.conditions_args;
    end
else
    ar.model(m).extra_conditions = {};
end

matVer = ver('MATLAB');

% AAA - Check if delay is there
%delayCh.modelAsString = fileread(['Models/' name '.def']); nicht bentigt
%wegen fid.str
delayCh.indicator = regexp(fid.str, '-\d->', 'Match');
if(~isempty(delayCh.indicator))
    delayCh.length = str2num(delayCh.indicator{1}(2));
    delayCh.position = 1;
    delayCh.bl = 1;
    delayCh.ctr = 1;
else
    delayCh.bl = 0;
end

% DESCRIPTION
[str, fid] = arTextScan(fid, '%s', 1, 'CommentStyle', ar.config.comment_string);
if(isempty(strfind(str{1},'DESCRIPTION')))
    arParsingError( fid, 'parsing model %s for DESCRIPTION', ar.model(m).name);
end

% check version
if(strcmp(str{1},'DESCRIPTION'))
    % def_version = 1;
elseif(strcmp(str{1},'DESCRIPTION-V2'))
    arParsingError( fid, 'DESCRIPTION-V2 not supported yet');
else
    arParsingError( fid, 'invalid version identifier: %s', cell2mat(str{1}));
end

% read comments
[str, fid] = arTextScan(fid, '%q', 1, 'CommentStyle', ar.config.comment_string);
ar.model(m).description = {};
while(~strcmp(str{1},'PREDICTOR'))
    ar.model(m).description(end+1,1) = str{1};
    [str, fid] = arTextScan(fid, '%q', 1, 'CommentStyle', ar.config.comment_string);
end

% PREDICTOR
[C, fid] = arTextScan(fid, '%s %q %q %q %n %n\n',1, 'CommentStyle', ar.config.comment_string);
arValidateInput( C, 'predictor', 'identifier for independent variable', 'unit type', 'unit', 'label for plotting' );
ar.model(m).t = cell2mat(C{1});
ar.model(m).tUnits(1) = C{2};
ar.model(m).tUnits(2) = C{3};
ar.model(m).tUnits(3) = C{4};
ar.model(m).tLim = [checkNum(C{5}, 0) checkNum(C{6}, 10)];

% COMPARTMENTS
ar.model(m).c = {};
ar.model(m).cUnits = {};
ar.model(m).pc = {};
ar.model(m).px = {};
[C, fid] = arTextScan(fid, '%s %q %q %q %f\n',1, 'CommentStyle', ar.config.comment_string);
if(~strcmp(C{1},'COMPARTMENTS'))
    arParsingError( fid, 'currently only one PREDICTOR allowed');
end
while(~strcmp(C{1},'STATES'))
    if(~strcmp(C{1},'COMPARTMENTS'))
        arValidateInput( C, 'compartments', 'compartment', 'unit type (i.e. V)', 'unit (i.e. pl)', 'label (i.e. "vol.")' );
        ar.model(m).c(end+1) = C{1};
        ar.model(m).cUnits(end+1,1) = C{2};
        ar.model(m).cUnits(end,2) = C{3};
        ar.model(m).cUnits(end,3) = C{4};
        
        if(isempty(C{5})||isnan(C{5}))
            ar.model(m).px(end+1) = {['vol_' cell2mat(C{1})]};
            ar.model(m).pc(end+1) = {['vol_' cell2mat(C{1})]};
        else
            ar.model(m).pc(end+1) = {num2str(C{5})};
        end
    end
    [C, fid] = arTextScan(fid, '%s %q %q %q %f\n',1, 'CommentStyle', ar.config.comment_string);
end

% STATES
ar.model(m).px0 = {};
ar.model(m).x = {};
ar.model(m).xNames = {};
ar.model(m).xUnits = {};
ar.model(m).cLink = [];
ar.model(m).qPlotX = [];
ar.model(m).qPositiveX = [];
[C, fid] = arTextScan(fid, '%s %q %q %q %s %n %q %n\n',1, 'CommentStyle', ar.config.comment_string);
while(~strcmp(C{1},'INPUTS'))
    if ( strcmp( C{1}, 'REACTIONS' ) )
        arParsingError( fid,  'Missing field INPUTS. This section should be specified after STATES and before REACTIONS. See: "Setting up models"' );
    end    
    
    arValidateInput( C, 'state', 'unique identifier', 'unit type (i.e. C)', 'unit (i.e. nM)', 'label for plots (i.e. "conc.")' );
    
    if(length(cell2mat(C{1}))<2)
        arParsingError( fid, 'STATE names need to be longer than 1');
    end
    if(isempty(symvar(sym(C{1}))))
        arParsingError( fid, 'STATE name ''%s'' is reserved by MATLAB. Please rename!',cell2mat(C{1}));
    end
    
    ar.model(m).x(end+1) = C{1};
    ar.model(m).xUnits(end+1,1) = C{2};
    ar.model(m).xUnits(end,2) = C{3};
    ar.model(m).xUnits(end,3) = C{4};
    if(~isempty(ar.model(m).c))
        qcomp = ismember(ar.model(m).c, C{5}); %R2013a compatible
        if(sum(qcomp)~=1)
            arParsingError( fid, 'unknown compartment %s', cell2mat(C{5}));
        end
        ar.model(m).cLink(end+1) = find(qcomp);
    end
    if(isempty(C{6}) || isnan(C{6}))
        ar.model(m).qPlotX(end+1) = 1;
    else
        ar.model(m).qPlotX(end+1) = C{6};
    end
    if(~isempty(cell2mat(C{7})))
        ar.model(m).xNames(end+1) = C{7};
    else
        ar.model(m).xNames{end+1} = ar.model(m).x{end};
    end
    if(isempty(C{8}) || isnan(C{8}))
        ar.model(m).qPositiveX(end+1) = 0;
    else
        ar.model(m).qPositiveX(end+1) = C{8};
    end
    ar.model(m).px0(end+1) = {['init_' cell2mat(C{1})]};
    
    [C, fid] = arTextScan(fid, '%s %q %q %q %s %n %q %n\n',1, 'CommentStyle', ar.config.comment_string);
    
    % AAA add delay states  
    if(strcmp(C{1},'INPUTS') & delayCh.bl == 1)
        
        delinpind = find(ismember(ar.model(end).x,'Delay_01'));
        
        for i = 2:delayCh.length
            C{1} = {sprintf('Delay_%02d', i)};
            C{2} = ar.model(m).xUnits(delinpind,1);
            C{3} = ar.model(m).xUnits(delinpind,2);
            C{4} = ar.model(m).xUnits(delinpind,3);
            %C{5} = compartments ergnzen
            C{6} = ar.model(m).qPlotX(delinpind);
            C{7} = {[ar.model(m).xNames{delinpind} '_' num2str(i)]};
            C{8} = ar.model(m).qPositiveX(delinpind);
            
            ar.model(m).x(end+1) = C{1};
            ar.model(m).xUnits(end+1,1) = C{2};
            ar.model(m).xUnits(end,2) = C{3};
            ar.model(m).xUnits(end,3) = C{4};
            
            if(~isempty(ar.model(m).c))
                qcomp = ismember(ar.model(m).c, C{5}); %R2013a compatible
                if(sum(qcomp)~=1)
                    arParsingError( fid, 'unknown compartment %s', cell2mat(C{5}));
                end
                ar.model(m).cLink(end+1) = find(qcomp);
            end
            if(isempty(C{6}) || isnan(C{6}))
                ar.model(m).qPlotX(end+1) = 1;
            else
                ar.model(m).qPlotX(end+1) = C{6};
            end
            if(~isempty(cell2mat(C{7})))
                ar.model(m).xNames(end+1) = C{7};
            else
                ar.model(m).xNames{end+1} = ar.model(m).x{end};
            end
            if(isempty(C{8}) || isnan(C{8}))
                ar.model(m).qPositiveX(end+1) = 0;
            else
                ar.model(m).qPositiveX(end+1) = C{8};
            end
            ar.model(m).px0(end+1) = {['init_' cell2mat(C{1})]};
        end
        
        C{1} = 'INPUTS'; %return to normal 
    end
    
end

% add delay states

% INPUTS
ar.model(m).u = {};
ar.model(m).uUnits = {};
ar.model(m).fu = {};
ar.model(m).uNames = {};
[C, fid] = arTextScan(fid, '%s %q %q %q %q %q\n',1, 'CommentStyle', ar.config.comment_string);
while(~strcmp(C{1},'REACTIONS') && ~strcmp(C{1},'REACTIONS-AMOUNTBASED') && ~strcmp(C{1},'ODES'))
    if(~strcmp(C{1},''))
        arValidateInput( C, 'input', 'unique input name', 'unit type (i.e. C)', 'unit (i.e. "units/cell")', 'plain text label for plots ("conc.")', 'input function' );
        if(sum(ismember(ar.model(m).x, C{1}))>0) %R2013a compatible
            arParsingError( fid, 'input %s already defined in STATES', cell2mat(C{1}));
        end
        ar.model(m).u(end+1) = C{1};
        ar.model(m).uUnits(end+1,1) = C{2};
        ar.model(m).uUnits(end,2) = C{3};
        ar.model(m).uUnits(end,3) = C{4};
        ar.model(m).fu(end+1,1) = C{5};
        if(~isempty(cell2mat(C{6})))
            ar.model(m).uNames(end+1) = C{6};
        else
            ar.model(m).uNames{end+1} = '';
        end
    end
    [C, fid] = arTextScan(fid, '%s %q %q %q %q %q\n',1, 'CommentStyle', ar.config.comment_string);
end
ar.model(m).qPlotU = ones(size(ar.model(m).u));

% input parameters
varlist = cellfun(@symvar, ar.model(m).fu, 'UniformOutput', false);
ar.model(m).pu = setdiff(vertcat(varlist{:}), {ar.model(m).t, ''}); %R2013a compatible

% REACTIONS (or ODES)
ar.model(m).N = [];
ar.model(m).v = {};
ar.model(m).fv = {};
ar.model(m).fv_source = {};
ar.model(m).fv_target = {};
ar.model(m).fv_sourceCoeffs = {};
ar.model(m).fv_targetCoeffs = {};
ar.model(m).reversible = [];
ar.model(m).fv_ma_reverse_pbasename = {};
ar.model(m).vUnits = {};
if(strcmp(C{1},'REACTIONS') || strcmp(C{1},'REACTIONS-AMOUNTBASED'))
    ar.model(m).isReactionBased = true;
    if(strcmp(C{1},'REACTIONS-AMOUNTBASED'))
        ar.model(m).isAmountBased = true;
    else
        ar.model(m).isAmountBased = false;
    end
    vcount = 1;
    %str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);
    
    % Read single line (easier to trace errors back to their line)
    
    % AAA: Finde line in der Delay stattfindet:
    % line = 'Delay_01 -> Delay_02 CUSTOM "k_delay*Delay_01"'
    % remainder = line;
    % fid = ;
    %
    % zum Beispiel
%     if fid.nlines == delayCh.position
%         line = 'Delay_01 -> Delay_02 CUSTOM "k_delay*Delay_01"'
%         remainder = line;
%     else
%         [ line, remainder, fid ] = readLine( fid, ar.config.comment_string );
%     end
%          


    [ line, remainder, fid ] = readLine( fid, ar.config.comment_string );
    %str = textscan(line, '%s', 1);
    
    
    [str, remainder] = grabtoken( remainder, '%s', 1 );
    while(~strcmp(str{1},'INVARIANTS') && ~strcmp(str{1},'DERIVED'))
        source = {};
        sourceCoeffs = [];

        if ( strcmp(str{1}, 'OBSERVABLES') || strcmp(str{1}, 'CONDITIONS') )
            arParsingError( fid, 'Missing field DERIVED. This section should be specified after REACTIONS and before OBSERVABLES / CONDITIONS. See: "Setting up models paragraph 1.7"');
        end
        nextValue = 1;
        
        
% while abfrage ergnzen um strcmp '->4->' 
        
        while(~strcmp(str{1},'->') && ~strcmp(str{1},'<->') && isempty(regexp(str{1}{1},'-\d->')))
            if(~strcmp(str{1},'0') && ~strcmp(str{1},'+'))
                % Check whether a stoichiometric coefficient is specified
                if ~isempty(str2num(str{1}{1})) %#ok
                    nextValue = str2num(str{1}{1}); %#ok
                else
                    source(end+1) = str{1}; %#ok<AGROW>
                    sourceCoeffs(end+1) = nextValue; %#ok<AGROW>
                    nextValue = 1;
                end
            end
            %str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);
            [str, remainder] = grabtoken( remainder, '%s', 1 );
            str{1}
            if ( isempty(str{1}) )
                arParsingError( fid, 'incomplete reaction definition in reaction %i: %s', vcount, line)
            end
        end
        if(sum(~ismember(source, ar.model(m).x)) > 0) %R2013a compatible
            arParsingError( fid, '%s\nundefined source species in reaction %i: %s', line, vcount, ...
                source{~ismember(source, ar.model(m).x)}) %R2013a compatible
        end
        
        if(strcmp(str{1},'<->'))
            reversible = true;
        else
            reversible = false;
        end
        
        % AAA check if there is a delay in the current line
                
% DELAY-ABFRAGE EINFHREN -> wenn positiv nach zuendelesen der aktuellen
% Zeile str abndern
        
        ar.model(m).reversible(end+1) = reversible;
        
        target = {};
        targetCoeffs = [];
        nextValue = 1;
        %str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);
        [str, remainder] = grabtoken( remainder, '%s', 1 );
        while(~strcmp(str{1},'CUSTOM') && ~strcmp(str{1},'MASSACTION') && ~strcmp(str{1},'MASSACTIONKD'))
            if(~strcmp(str{1},'0') && ~strcmp(str{1},'+'))
                % Check whether a stoichiometric coefficient is specified
                if ( ~isempty(str2num(str{1}{1})) )  %#ok
                    nextValue = str2num(str{1}{1});   %#ok
                else
                    target(end+1)       = str{1}; %#ok<AGROW> 
                    targetCoeffs(end+1) = nextValue; %#ok<AGROW>
                    nextValue = 1;
                end
            end
            %str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);
            [str, remainder] = grabtoken(remainder, '%s', 1);
            
            if ( isempty( str{1} ) )
                arParsingError( fid, 'missing keyword CUSTOM, MASSACTION or MASSACTIONKD before reaction rate expression');
            end
        end
        if(sum(~ismember(target, ar.model(m).x)) > 0) %R2013a compatible
            arParsingError( fid, 'undefined target species in reaction %i: %s', vcount, ...
                target{~ismember(target, ar.model(m).x)}) %R2013a compatible
        end
        
        % infer flux units
        if(~isempty(source))
            ix = find(ismember(ar.model(m).x, source{1})); %R2013a compatible
        elseif(~isempty(target))
            ix = find(ismember(ar.model(m).x, target{1})); %R2013a compatible
        else
            arParsingError( fid, 'reaction with empty N');
        end
        ar.model(m).vUnits{end+1,1} = [ar.model(m).xUnits{ix,1} '/' ar.model(m).tUnits{1}];
        ar.model(m).vUnits{end,2} = [ar.model(m).xUnits{ix,2} '/' ar.model(m).tUnits{2}];
        ar.model(m).vUnits{end,3} = [ar.model(m).xUnits{ix,3} '/' ar.model(m).tUnits{3}];
        
        if(strcmp(str{1},'MASSACTION'))
            massaction = true;
            massactionkd = false;
        else
            massaction = false;
        end
        if(strcmp(str{1},'MASSACTIONKD'))
            massaction = true;
            massactionkd = true;
        end
        
        [C, remainder] = grabtoken(remainder, '%q %q', 1);
        
        %C = arTextScan(fid, '%q %q\n', 1, 'CommentStyle', ar.config.comment_string);
        arValidateInput(C, 'REACTIONS', 'reaction rate expression' );
        str = C(1);
        if ( ~isempty(C{2}) )
            ar.model(m).v{end+1} = cell2mat(C{2});
        else
            ar.model(m).v{end+1} = sprintf('v_%d', length(ar.model(m).v) );
        end
        
        ar.model(m).fv_ma_reverse_pbasename{end+1} = '';
        if(~massaction)
            if(reversible)
                warning('Reversible reactions for type CUSTOM in experimental phase. Proceed with caution!');
            end
            ar.model(m).fv(end+1,1) = str{1};
            
            % check for negative fluxes possible
            if(ar.config.checkForNegFluxes)
                if (~reversible)
                    try
                        symtmp = sym(str{1});
                    catch
                        if ( iscell( str{1} ) )
                            arParsingError( fid,  'Parsing error in REACTIONS at %s in model %d', str{1}{:}, m );
                        else
                            arParsingError( fid,  'Parsing error in REACTIONS at %s in model %d', str{1}, m );
                        end
                    end
                    for j=1:length(source)
                        symtmpsubs = subs(symtmp, sym(source{j}), 0);
                        if(symtmpsubs~=0)
                            arFprintf(1, 2, 'Possible negative flux in reaction #%i:\n', length(ar.model(m).fv));
                            arFprintf(1, 2, '%s : %s\n', arAssembleReactionStr(source, target, false, sourceCoeffs, targetCoeffs), cell2mat(str{1}));
                            arFprintf(1, 2, 'Source species %s missing ?\n\n', source{j});
                            arFprintf(1, 2, 'Deactivate this error message with: ar.config.checkForNegFluxes = false;\n\n');
                            arParsingError( fid, 'Possible negative fluxes in reaction');
                        end
                    end
                else
                    symtmp = sym(str{1});
                    for j=1:length(source)
                        symtmpsubs = subs(symtmp, sym(source{j}), 0);
                        for k=1:length(target)
                            symtmpsubs = subs(symtmpsubs, sym(target{k}), 0);
                        end
                        
                        if(symtmpsubs~=0)
                            arFprintf(1, 2, 'Possible flux in reaction without presence of source #%i:\n', length(ar.model(m).fv));
                            arFprintf(1, 2, '%s : %s\n', arAssembleReactionStr(source, target, false, sourceCoeffs, targetCoeffs), cell2mat(str{1}));
                            arFprintf(1, 2, 'Source species %s missing ?\n\n', source{j});
                            arFprintf(1, 2, 'Deactivate this error message with: ar.config.checkForNegFluxes = false;\n\n');
                            warning('Possible erroneous fluxes in reaction');
                        end                        
                    end
                    for j=1:length(target)
                        symtmpsubs = subs(symtmp, sym(target{j}), 0);
                        for k=1:length(source)
                            symtmpsubs = subs(symtmpsubs, sym(source{k}), 0);
                        end
                        
                        if(symtmpsubs~=0)
                            arFprintf(1, 2, 'Possible flux in reaction without presence of product #%i:\n', length(ar.model(m).fv));
                            arFprintf(1, 2, '%s : %s\n', arAssembleReactionStr(source, target, false, sourceCoeffs, targetCoeffs), cell2mat(str{1}));
                            arFprintf(1, 2, 'Product species %s missing ?\n\n', target{j});
                            arFprintf(1, 2, 'Deactivate this error message with: ar.config.checkForNegFluxes = false;\n\n');
                            warning('Possible erroneous fluxes in reaction');
                        end                        
                    end                    
                end
            end
        else
            if(~reversible)
                ar.model(m).fv{end+1,1} = cell2mat(str{1});
                for j=1:length(source)
                    if ( sourceCoeffs ~= 1 )
                        ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} '*' source{j} '^' num2str(sourceCoeffs(j))];
                    else
                        ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} '*' source{j} ];
                    end
                end
            else
                if(massactionkd)
                    ar.model(m).fv{end+1,1} = [cell2mat(str{1}) '_1*' cell2mat(str{1}) '_2'];
                else
                    ar.model(m).fv{end+1,1} = [cell2mat(str{1}) '_1'];
                end
                ar.model(m).fv_ma_reverse_pbasename{end} = cell2mat(str{1});
                for j=1:length(source)
                    if ( sourceCoeffs ~= 1 )
                        ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} '*' source{j} '^' num2str(sourceCoeffs(j))];
                    else
                        ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} '*' source{j} ];
                    end
                end
            end
        end
        
        % setup N
        ar.model(m).N(1:length(ar.model(m).x),vcount) = 0;
        for jj=1:length(source)
            for j=find(ismember(ar.model(m).x, source{jj})) %R2013a compatible
                ar.model(m).N(j, vcount) = ar.model(m).N(j, vcount) - sourceCoeffs(jj);
            end
        end
        for jj=1:length(target)
            for j=find(ismember(ar.model(m).x, target{jj})) %R2013a compatible
                ar.model(m).N(j, vcount) = ar.model(m).N(j, vcount) + targetCoeffs(jj);
            end
        end
        ar.model(m).fv_source{end+1,1} = source;
        ar.model(m).fv_target{end+1,1} = target;
        ar.model(m).fv_sourceCoeffs{end+1,1} = sourceCoeffs;
        ar.model(m).fv_targetCoeffs{end+1,1} = targetCoeffs;        
        
        % check for inconsistent educt compartments
        if(~isempty(ar.model(m).c) && ~ar.model(m).isAmountBased)
            for j=1:size(ar.model(m).N,2)
                if(length(unique(ar.model(m).cLink(ar.model(m).N(:,j)>0)))>1)
                    arParsingError( fid, 'efflux from different compartments in reaction %s', ...
                        ar.model(m).fv{end});
                end
                if(length(unique(ar.model(m).cLink(ar.model(m).N(:,j)<0)))>1)
                    arParsingError( fid, 'influx from different compartments in reaction %s', ...
                        ar.model(m).fv{end});
                end
            end
        end
        
        vcount = vcount + 1;
        
        % setup reversed reaction
        if(massaction && reversible)
            ar.model(m).fv{end+1,1} = [cell2mat(str{1}) '_2'];
            ar.model(m).fv_source{end+1,1} = ar.model(m).fv_target{end,1};
            ar.model(m).fv_target{end+1,1} = ar.model(m).fv_source{end,1};
            ar.model(m).fv_ma_reverse_pbasename{end+1} = cell2mat(str{1});
            for j=1:length(target)
                if ( targetCoeffs(j) ~= 1 )
                    ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} '*' target{j} '^' num2str(targetCoeffs(j))];
                else
                    ar.model(m).fv{end,1} = [ar.model(m).fv{end,1} '*' target{j}];
                end
            end
            
            % infer flux units
            if(~isempty(target))
                ix = find(ismember(ar.model(m).x, target{1})); %R2013a compatible
            elseif(~isempty(source))
                ix = find(ismember(ar.model(m).x, source{1})); %R2013a compatible
            else
                arParsingError( fid, 'reaction with empty N');
            end
            ar.model(m).vUnits{end+1,1} = [ar.model(m).xUnits{ix,1} '/' ar.model(m).tUnits{1}];
            ar.model(m).vUnits{end,2} = [ar.model(m).xUnits{ix,2} '/' ar.model(m).tUnits{2}];
            ar.model(m).vUnits{end,3} = [ar.model(m).xUnits{ix,3} '/' ar.model(m).tUnits{3}];
            ar.model(m).v{end+1} = cell2mat(C{2});
            
            % setup N
            ar.model(m).N(1:length(ar.model(m).x),vcount) = 0;
            for jj=1:length(source)
                for j=find(ismember(ar.model(m).x, source{jj})) %R2013a compatible
                    ar.model(m).N(j, vcount) = ar.model(m).N(j, vcount) + sourceCoeffs(jj);
                end
            end
            for jj=1:length(target)
                for j=find(ismember(ar.model(m).x, target{jj})) %R2013a compatible
                    ar.model(m).N(j, vcount) = ar.model(m).N(j, vcount) - targetCoeffs(jj);
                end
            end
            
            % check for inconsistent educt compartments
            if(~isempty(ar.model(m).c))
                for j=1:size(ar.model(m).N,2)
                    if(length(unique(ar.model(m).cLink(ar.model(m).N(:,j)>0)))>1)
                        arParsingError( fid, 'efflux from different compartments in reaction %s', ...
                            ar.model(m).fv{end});
                    end
                    if(length(unique(ar.model(m).cLink(ar.model(m).N(:,j)<0)))>1)
                        arParsingError( fid, 'influx from different compartments in reaction %s', ...
                            ar.model(m).fv{end});
                    end
                end
            end
            
            vcount = vcount + 1;
        end
        
        %str = textscan(fid, '%s',1, 'CommentStyle', ar.config.comment_string);
        % No string left? Grab a new one
        
        %if delayCh.ctr == 1
            %[ line, remainder, fid ] = readLine( fid, ar.config.comment_string );
            if ~isempty(regexp(line, '-\d->'))
                delayCh.enterDel = 1;
                %delayCh.ctr = delayCh.ctr + 1;
            end
            
            if delayCh.enterDel == 1 & delayCh.ctr < delayCh.length
            %if delayCh.ctr > 1 && delayCh.ctr < delayCh.length
            line = sprintf('Delay_%02d -> Delay_%02d CUSTOM "k_delay*Delay_%02d"',...
                delayCh.ctr, delayCh.ctr+1, delayCh.ctr);
            remainder = line;
            delayCh.ctr = delayCh.ctr + 1; %es wird gar keine neue line
            %geladen also greift immer erste if clause
            end
            %[ line, remainder, fid ] = readLine( fid, ar.config.comment_string );
        %end %nach unten setzen?
        
        if isempty( remainder )
            if delayCh.ctr >= delayCh.length | delayCh.ctr == 1
            [ line, remainder, fid ] = readLine( fid, ar.config.comment_string );
            end
        end
        
        
        [str, remainder] = grabtoken( remainder, '%s', 1 );
    end
elseif(strcmp(C{1},'ODES'))
    ar.model(m).isReactionBased = false;
    [str, fid] = arTextScan(fid, '%q\n',1, 'CommentStyle', ar.config.comment_string);
    ode_count = 0;
    while(~strcmp(str{1},'INVARIANTS') && ~strcmp(str{1},'DERIVED'))
        if(~strcmp(str{1},''))
            ode_count = ode_count + 1;
            ar.model(m).fv{end+1,1} = cell2mat(str{1});
            ar.model(m).fv_ma_reverse_pbasename{end+1} = '';
            ar.model(m).vUnits{end+1,1} = [ar.model(m).xUnits{ode_count,1} '/' ar.model(m).tUnits{1}];
            ar.model(m).vUnits{end,2} = [ar.model(m).xUnits{ode_count,2} '/' ar.model(m).tUnits{2}];
            ar.model(m).vUnits{end,3} = [ar.model(m).xUnits{ode_count,3} '/' ar.model(m).tUnits{3}];
        end
        [str, fid] = arTextScan(fid, '%q\n',1, 'CommentStyle', ar.config.comment_string);
    end
    if(ode_count ~= length(ar.model(m).x))
        arParsingError( fid, 'number of ODES ~= number of variables');
    end
    ar.model(m).N = eye(length(ar.model(m).x));
end
ar.model(m).qPlotV = ones(1,length(ar.model(m).fv));
if(isempty(ar.model(m).fv))
    ar.model(m).isReactionBased = false;
end

% dynamic parameters
ar.model(m).pvs = cell(size(ar.model(m).fv));
ar.model(m).pv = {};
for jv=1:length(ar.model(m).fv)
    varlist = symvar(ar.model(m).fv{jv});
    ar.model(m).pvs{jv} = setdiff(varlist, union(ar.model(m).t, union(ar.model(m).x, ar.model(m).u))); %R2013a compatible
    ar.model(m).pv = union(ar.model(m).pv, ar.model(m).pvs{jv});
end
ar.model(m).px = union(union(ar.model(m).pv, ar.model(m).px), ar.model(m).px0); %R2013a compatible
ar.model(m).p = union(ar.model(m).px, ar.model(m).pu); %R2013a compatible

% setup rhs
C = cell(size(ar.model(m).N));
C_par = cell(size(ar.model(m).N));
if(length(ar.model(m).c)>1)    
    if(~isfield(ar.model(m),'isAmountBased') || ~ar.model(m).isAmountBased)
        for j=1:size(ar.model(m).N,1) % for every species j
            qinfluxwitheducts = ar.model(m).N(j,:) > 0 & sum(ar.model(m).N < 0,1) > 0;
            eductcompartment = zeros(size(qinfluxwitheducts));
            for jj=find(qinfluxwitheducts)
				eductcompartment(jj) = unique(ar.model(m).cLink(ar.model(m).N(:,jj)<0)); %R2013a compatible
            end
            
            cfaktor = cell(size(qinfluxwitheducts));
            cfaktor_par = cell(size(qinfluxwitheducts));
            for jj=1:size(ar.model(m).N,2) % for every reaction jj
                if(qinfluxwitheducts(jj) && eductcompartment(jj)~=ar.model(m).cLink(j))
                    cfaktor{jj} = [ar.model(m).pc{eductcompartment(jj)} '/' ...
                        ar.model(m).pc{ar.model(m).cLink(j)}];
                    cfaktor_par{jj} = [ar.model(m).c{eductcompartment(jj)} '/' ...
                        ar.model(m).c{ar.model(m).cLink(j)}];
                else
                    cfaktor{jj} = '1';
                    cfaktor_par{jj} = '1';
                end
            end
            C(j,:) = transpose(cfaktor);
            C_par(j,:) = transpose(cfaktor_par);
        end
    else
        for j=1:size(ar.model(m).N,1) % for every species j
            for jj=1:size(ar.model(m).N,2) % for every reaction jj
                C{j,jj} = ['1/' ar.model(m).pc{ar.model(m).cLink(j)}];
                C_par{j,jj} = ['1/' ar.model(m).c{ar.model(m).cLink(j)}];
            end
        end
    end
else
    for j=1:size(ar.model(m).N,1) % for every species j
        for jj=1:size(ar.model(m).N,2) % for every reaction jj
            C{j,jj} = '1';
            C_par{j,jj} = '1';
        end
    end
end
ar.model(m).fx = cell(length(ar.model(m).x),1);
ar.model(m).fx_par = cell(length(ar.model(m).x),1);

% initialize symbolic variables
% Joep: I have removed this. Not sure if this serves any purpose? Removing
% it seems to not affect any of the integration tests.
%if(~isempty(ar.model(m).x))
%    eval(['syms ' sprintf('%s ',ar.model(m).x{:})]);
%end
%if(~isempty(ar.model(m).p))
%    eval(['syms ' sprintf('%s ',ar.model(m).p{:})]);
%end
%if(~isempty(ar.model(m).u))
%    eval(['syms ' sprintf('%s ',ar.model(m).u{:})]);
%end
ar.model(m).Cm = C;
ar.model(m).Cm_par = C_par;
tmpfx = (sym(ar.model(m).N).*sym(C)) * sym(ar.model(m).fv);
tmpfx_par = (sym(ar.model(m).N).*sym(C_par)) * sym(ar.model(m).fv);

for j=1:length(ar.model(m).x) % for every species j
    if ~isempty(tmpfx)
        ar.model(m).fx{j} = char(tmpfx(j));
        ar.model(m).fx_par{j} = char(tmpfx_par(j));
    else
        ar.model(m).fx{j} = char('0');
        ar.model(m).fx_par{j} = char('0');
    end
end


% DERIVED (previously INVARIANTS)
if(strcmp(str{1},'INVARIANTS'))
    arParsingError( fid, ['Section INVARIANTS in model definition file is deprecated! ' ...
        'Please replace by DERIVED and see usage in: ' ...
        'https://github.com/Data2Dynamics/d2d/wiki/Setting%20up%20models']);
end
derivedVariablesInRates = 0;
ar.model(m).z = {};
ar.model(m).zUnits = {};
ar.model(m).fz = {};
[C, fid] = arTextScan(fid, '%s %q %q %q %q\n',1, 'CommentStyle', ar.config.comment_string);
while(~strcmp(C{1},'CONDITIONS') && ~strcmp(C{1},'SUBSTITUTIONS') && ~strcmp(C{1},'OBSERVABLES'))
    if(~strcmp(C{1},''))
        arValidateInput( C, 'derived', 'unique identifier', 'unit type (i.e. C)', 'unit (i.e. "units/cell")', 'plain text label for plots ("conc.")', 'derived function expression' );
        if(sum(ismember(ar.model(m).x, C{1}))>0) %R2013a compatible
            arParsingError( fid, 'derived variable %s already defined in STATES', cell2mat(C{1}));
        end
        if(sum(ismember(ar.model(m).u, C{1}))>0) %R2013a compatible
            arParsingError( fid, 'derived variable %s already defined in INPUTS', cell2mat(C{1}));
        end
        % Found derived variable in parameter list. See if it is used in
        % either the inputs or the reaction equations. If the former, fail
        % the loading, since we cannot resolve the state values at the time
        % the inputs are computed. If the latter => substitute them in!
        if(sum(ismember(ar.model(m).p, C{1}))>0) %R2013a compatible
            ar.model(m).p(ismember(ar.model(m).p, C{1})) = [];
            derivedVariablesInRates = 1;
            fail = 0;
            inputVariables = cellfun(@symvar, ar.model(m).fu, 'UniformOutput', false);
            for ju = 1 : length( inputVariables )
                fail = fail | max( ismember( inputVariables{ju}, C{1} ) );
            end
            if ( fail )
                arParsingError( fid, 'derived variable %s already defined as parameter in INPUT section', cell2mat(C{1}));
            end
        end
        ar.model(m).z(end+1) = C{1};
        ar.model(m).zUnits(end+1,1) = C{2};
        ar.model(m).zUnits(end,2) = C{3};
        ar.model(m).zUnits(end,3) = C{4};
        ar.model(m).fz(end+1,1) = C{5};
    end
    [C, fid] = arTextScan(fid, '%s %q %q %q %q\n',1, 'CommentStyle', ar.config.comment_string);
end

% Perform (repeated) derived substitutions
if ( derivedVariablesInRates )
    for a = 1 : length( ar.model(m).fv )
        ar.model(m).fv{a} = char( arSubsRepeated(sym(ar.model(m).fv{a}), ar.model(m).z, ar.model(m).fz, matVer.Version) );
    end
    arFprintf(2, '=> Substituting derived variables in reaction equation.\n' );
end


ar.model(m).qPlotZ = ones(size(ar.model(m).z));

% derived variables parameters
varlist = cellfun(@symvar, ar.model(m).fz, 'UniformOutput', false);
ar.model(m).pz = setdiff(setdiff(vertcat(varlist{:}), {ar.model(m).t, ''}), union(ar.model(m).x, union(ar.model(m).u, ar.model(m).z))); %R2013a compatible
ar.model(m).px = union(ar.model(m).px, ar.model(m).pz); %R2013a compatible
ar.model(m).p = union(ar.model(m).p, ar.model(m).pz); %R2013a compatible


if(strcmp(C{1},'OBSERVABLES'))
    
    % OBSERVABLES
    ar.model(m).y = {};
    ar.model(m).yNames = {};
    ar.model(m).yUnits = {};
    ar.model(m).normalize = [];
    ar.model(m).logfitting = [];
    ar.model(m).logplotting = [];
    ar.model(m).fy = {};
    [C, fid] = arTextScan(fid, '%s %q %q %q %n %n %q %q\n',1, 'CommentStyle', ar.config.comment_string);
    while(~strcmp(C{1},'ERRORS'))
        if ( strcmp( C{1}, 'CONDITIONS' ) || strcmp( C{1}, 'SUBSTITUTIONS' ) )
            arParsingError( fid,  'When OBSERVABLES section is specified; ERRORS section must also be specified.' );
        end
        arValidateInput( C, 'observable', 'unique identifier', 'unit type (i.e. C)', 'unit (i.e. "units/cell")', 'plain text label for plots ("conc.")', 'indicator whether data should be scaled to 1 (0 or 1)', 'Indicator whether date should be treated in log-space (0 or 1)', 'Mathematical expression for observable' );
        ar.model(m).y(end+1) = C{1};
        ar.model(m).yUnits(end+1,1) = C{2};
        ar.model(m).yUnits(end,2) = C{3};
        ar.model(m).yUnits(end,3) = C{4};
        ar.model(m).normalize(end+1) = C{5};
        ar.model(m).logfitting(end+1) = C{6};
        ar.model(m).logplotting(end+1) = C{6};
        ar.model(m).fy(end+1,1) = C{7};
        if(~isempty(cell2mat(C{8})))
            ar.model(m).yNames(end+1) = C{8};
        else
            ar.model(m).yNames(end+1) = ar.model(m).y(end);
        end
        [C, fid] = arTextScan(fid, '%s %q %q %q %n %n %q %q\n',1, 'CommentStyle', ar.config.comment_string);
        if(sum(ismember(ar.model(m).x, ar.model(m).y{end}))>0) %R2013a compatible
            arParsingError( fid, '%s already defined in STATES', ar.model(m).y{end});
        end
        if(sum(ismember(ar.model(m).u, ar.model(m).y{end}))>0) %R2013a compatible
            arParsingError( fid, '%s already defined in INPUTS', ar.model(m).y{end});
        end
        if(sum(ismember(ar.model(m).z, ar.model(m).y{end}))>0) %R2013a compatible
            arParsingError( fid, '%s already defined in DERIVED', ar.model(m).y{end});
        end
        if(sum(ismember(ar.model(m).p, ar.model(m).y{end}))>0) %R2013a compatible
            arParsingError( fid, '%s already defined as parameter', ar.model(m).y{end});
        end
    end
    
    % observation parameters
    varlist = cellfun(@symvar, ar.model(m).fy, 'UniformOutput', false);
    ar.model(m).py = setdiff(setdiff(vertcat(varlist{:}), union(union(union(ar.model(m).x, ar.model(m).u), ar.model(m).z), ar.model(m).z)), {ar.model(m).t, ''}); %R2013a compatible
    
    % ERRORS
    ar.model(m).fystd = cell(size(ar.model(m).fy));
    [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string);
    while(~(strcmp(C{1},'CONDITIONS') || strcmp(C{1},'SUBSTITUTIONS')))
        qy = ismember(ar.model(m).y, C{1}); %R2013a compatible
        
        if(sum(qy)<1)
            arParsingError( fid, 'Unknown observable in error specification %s.', cell2mat(C{1}));
        elseif sum(qy)>1
            arParsingError( fid, 'Observable %s seems to occur more than once.', cell2mat(C{1}));            
        end
        
        %check and error if observable in log and fystd = rel + abs error
        y_var_name = setdiff(symvar(ar.model(m).fy{qy}),ar.model(m).py);
        reg_string = ['((?<=\W)|^)(',C{1}{1},'|'];
        for jreg = 1:length(y_var_name)
            if(jreg<length(y_var_name))
                reg_string = [reg_string ,y_var_name{jreg},'|'];
            else
                reg_string = [reg_string ,y_var_name{jreg},')'];
            end
        end
        reg_string = [reg_string '((?=\W)|$)'];
        if(~isempty(regexp(C{2}{1},reg_string,'ONCE')) && ar.model(m).logfitting(qy))
            warning(['You are trying to set up a relative error model within a log transformation. \n%s' ...
            'Comment out this error if you want to proceed anyway. To implement an absolute error in log, \n' ...
            'you can try the approach: \nyObs = sd_yObs + 1/2 * (a+sqrt((a)^2)), a = (offset - yObs-sd_yObs) \n, with hard set or fitted offset (on log-scale) \n'],C{2}{1})
            arParsingError( fid, 'Revise error model')
        end
        arValidateInput( C, 'error', 'observable identifier', 'expression for the error model' );
        
        ar.model(m).fystd(qy) = C{2};
        [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string);
        if ( isempty( C{1} ) )
            arParsingError( fid,  'Missing field CONDITIONS' );
        end
    end
    
    if (length(ar.model(m).fystd)<length(ar.model(m).fy) || sum(cellfun(@isempty, ar.model(m).fystd))>0)
        diffErr = ar.model(m).y(cellfun(@isempty, ar.model(m).fystd)>0);
        if ( length(ar.model(m).fystd)<length(ar.model(m).fy) )
            diffErr = union( ar.model(m).y( length(ar.model(m).fystd) + 1 : end ), diffErr );
        end
        
        arParsingError( fid, 'Some observables do not have an error model defined. Observable(s) without error model: %s\n', sprintf( '%s ', diffErr{:} ) );
    end
    
    % error parameters
    varlist = cellfun(@symvar, ar.model(m).fystd, 'UniformOutput', false);
    ar.model(m).pystd = setdiff(vertcat(varlist{:}), union(union(union(union(union(ar.model(m).x, ar.model(m).u), ar.model(m).z), ... %R2013a compatible
        ar.model(m).z), ar.model(m).y), ar.model(m).t));
    
    % add to parameters needed for model
    ar.model(m).p = union(union(ar.model(m).p, ar.model(m).py), ar.model(m).pystd);
end

% SUBSTITUTIONS (beta)
substitutions = 0;
if ( strcmp(C{1},'SUBSTITUTIONS') )
    if(str2double(matVer.Version)>=8.4)
        [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string);
    else
        [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string, 'BufSize', 2^16);
    end
    
    % Substitutions
    fromSubs = {};
    toSubs = {};
    ismodelpar = [];

    % Fetch desired substitutions
    while(~isempty(C{1}) && ~strcmp(C{1},'CONDITIONS'))
        fromSubs(end+1)     = C{1}; %#ok<AGROW>
        toSubs(end+1)       = C{2}; %#ok<AGROW>
        ismodelpar(end+1)   = sum(ismember(ar.model(m).p, C{1})); %#ok<AGROW>

        if(str2double(matVer.Version)>=8.4)
            [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string);
        else
            [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string, 'BufSize', 2^16-1);
        end
        
        if ( ~strcmp(C{1},'CONDITIONS') )
            arValidateInput( C, 'substitution', 'substitution identifier', 'expression for the substitution' );
        end
    end

    if ( sum(ismodelpar) > 0 )
        s = sprintf( '%s\n', fromSubs{ismodelpar>0} );
        arParsingError( fid,  'Cannot substitute model parameters. These following parameters belong under CONDITIONS:\n%s', s );
    end

    % Perform selfsubstitutions
    if ( ~isempty(fromSubs) )
        substitutions = 1;
        toSubs = arSubsRepeated( toSubs, fromSubs, toSubs, str2double(matVer.Version) );
    end
end


% CONDITIONS
if(str2double(matVer.Version)>=8.4)
    [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string);
else
    [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string, 'BufSize', 2^16);
end
ar.model(m).fp = transpose(ar.model(m).p);

if ( substitutions )
	% Conditions
    from        = {};
    to          = {};
    ismodelpar  = [];
     
    % Fetch desired conditions
    while(~isempty(C{1}) && ~(strcmp(C{1},'PARAMETERS') || strcmp(C{1}, 'RANDOM')))
        arValidateInput( C, 'condition', 'model parameter', 'new expression' );
        from(end+1)         = C{1}; %#ok<AGROW>
        to(end+1)           = C{2}; %#ok<AGROW>
        ismodelpar(end+1)   = sum(ismember(ar.model(m).p, C{1})); %#ok<AGROW>

        if(str2double(matVer.Version)>=8.4)
            [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string);
        else
            [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string, 'BufSize', 2^16-1);
        end
    end
    
    % Extra conditions specified at compile time
    if ( opts.conditions )
        for a = 1 : length( opts.conditions_args )
            from(end+1)         = opts.conditions_args{a,1}; %#ok<AGROW>
            to(end+1)           = opts.conditions_args{a,2}; %#ok<AGROW>
            ismodelpar(end+1)   = sum(ismember(ar.model(m).p, from(end))); %#ok<AGROW>
        end
    end
        
    % Perform substitutions (self-substitutions were already done)
    to = arSubsRepeated( to, fromSubs, toSubs, str2double(matVer.Version) );
    
    % Store substitutions in ar structure
    for a = 1 : length( from )
        qcondpara = ismember(ar.model(m).p, from{a}); %R2013a compatible
        if(sum(qcondpara)>0)
            ar.model(m).fp{qcondpara} = ['(' to{a} ')'];
        else
            warning('unknown parameter in conditions: %s (did you mean to place it under SUBSTITUTIONS?)', from{a}); %#ok<WNTAG>
        end
    end
else
    % Old code path
    while(~isempty(C{1}) && ~(strcmp(C{1},'PARAMETERS') || strcmp(C{1}, 'RANDOM')))
        arValidateInput( C, 'condition', 'model parameter', 'new expression' );
        qcondpara = ismember(ar.model(m).p, C{1}); %R2013a compatible
        if(sum(qcondpara)>0)
            ar.model(m).fp{qcondpara} = ['(' cell2mat(C{2}) ')'];
        else
            warning('unknown parameter in conditions: %s (did you mean to place it under SUBSTITUTIONS?)', cell2mat(C{1})); %#ok<WNTAG>
        end
        if(str2double(matVer.Version)>=8.4)
            [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string);
        else
            [C, fid] = arTextScan(fid, '%s %q\n',1, 'CommentStyle', ar.config.comment_string, 'BufSize', 2^16-1);
        end
    end
end

ar.model(m).prand = {};
ar.model(m).rand_type = [];
if ( strcmp(C{1}, 'RANDOM' ) )    
    [C, fid] = arTextScan(fid, '%s %s\n',1, 'CommentStyle', ar.config.comment_string);
    while(~isempty(C{1}) && ~strcmp(C{1},'PARAMETERS'))
        ar.model(m).prand{end+1} = cell2mat(C{1});
        if(strcmp(C{2}, 'INDEPENDENT'))
            ar.model(m).rand_type(end+1) = 0;
        elseif(strcmp(C{2}, 'NORMAL'))
            ar.model(m).rand_type(end+1) = 1;
        else
            warning('unknown random type %s', cell2mat(C{2}));  %#ok<WNTAG>
        end
        [C, fid] = arTextScan(fid, '%s %s\n',1, 'CommentStyle', ar.config.comment_string);
    end    
end
    
% extra conditional parameters
varlist = cellfun(@symvar, ar.model(m).fp, 'UniformOutput', false);
ar.model(m).pcond = setdiff(setdiff(setdiff(vertcat(varlist{:}), ar.model(m).p), ar.model(m).x), ar.model(m).u); %R2013a compatible

% PARAMETERS
if(~isfield(ar, 'pExternLabels'))
    ar.pExternLabels = {};
    ar.pExtern = [];
    ar.qFitExtern = [];
    ar.qLog10Extern = [];
    ar.lbExtern = [];
    ar.ubExtern = [];
end
[C, fid] = arTextScan(fid, '%s %f %n %n %f %f\n',1, 'CommentStyle', ar.config.comment_string);

while(~isempty(C{1}))
    ar.pExternLabels(end+1) = C{1};
    ar.pExtern(end+1) = C{2};
    ar.qFitExtern(end+1) = C{3};
    ar.qLog10Extern(end+1) = C{4};
    ar.lbExtern(end+1) = C{5};
    ar.ubExtern(end+1) = C{6};
    [C, fid] = arTextScan(fid, '%s %f %n %n %f %f\n',1, 'CommentStyle', ar.config.comment_string);
end

if ~isstruct( fid )
    fclose(fid);
end

% Check whether the user specified any variables with reserved words. This
% would be problematic later.
for a = 1 : length( ar.model(m).fu )
    arCheckReservedWords( symvar(ar.model(m).fu{a}), 'input function', ar.model(m).u{a} );
end
if ( isfield( ar.model(m), 'fy' ) )
    for a = 1 : length( ar.model(m).fy )
        arCheckReservedWords( symvar(ar.model(m).fy{a}), 'observation function', ar.model(m).y{a} );
    end
    for a = 1 : length( ar.model(m).fystd )
        arCheckReservedWords( symvar(ar.model(m).fystd{a}), 'observation standard deviation', ar.model(m).y{a} );
    end
end
if ( isfield( ar.model(m), 'fp' ) )
    for a = 1 : length( ar.model(m).fp )
        arCheckReservedWords( symvar(ar.model(m).fp{a}), 'parameter transformation', ar.model(m).p{a} );
    end
end
for a = 1 : length( ar.model(m).fx )
    arCheckReservedWords( symvar(ar.model(m).fx{a}), 'right hand side', ar.model(m).x{a} );
end

arCheckReservedWords( ar.model(m).p, 'parameters' );
arCheckReservedWords( ar.model(m).x, 'state variables' );
if ( isfield( ar.model(m), 'y' ) )
    arCheckReservedWords( ar.model(m).y, 'observables' );
end
if ( isfield( ar.model(m), 'z' ) )
    arCheckReservedWords( ar.model(m).z, 'derived variables' );
end
if ( isfield( ar.model(m), 'u' ) )
    arCheckReservedWords( ar.model(m).u, 'inputs' );
end
arCheckReservedWords( ar.model(m).c, 'compartments' );

ar = orderfields(ar);
ar.model = orderfields(ar.model);


function [ line, remainder, fid ] = readLine( fid, commentStyle )
    line = '';
    while ( isempty(line) )
        [line, fid] = arTextScan(fid, '%[^\n]' ); 
        line = strtrim(line{1}{1});
        Q = strfind( line, commentStyle );
        if ( ~isempty(Q) )
            line = line(1:Q-1);
        end
    end
    remainder = line;
    
    
function [str, remainder] = grabtoken( inputString, varargin )
    if ( isempty( inputString ) )
        str{1} = {};
        remainder = '';
        return;
    end

	[str, pos] = textscan(inputString, varargin{:});
	remainder = inputString(pos+1:end);    

function num = checkNum( num, defaultValue )
    if ( ~isnumeric( num ) || isempty( num ) || isnan( num ) )
        num = defaultValue;
    end
##### SOURCE END #####
--></body></html>